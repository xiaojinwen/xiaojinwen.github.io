{"meta":{"title":"个人博客-xiaojinwen","subtitle":"xiaojinwen","description":"个人日常","author":"xiaojinwen","url":"https://xiaojinwen.github.io"},"pages":[],"posts":[{"title":"关于列表水平展示的方法","slug":"关于列表水平展示的方法","date":"2018-09-07T10:38:22.000Z","updated":"2018-09-07T10:59:01.060Z","comments":true,"path":"2018/09/07/关于列表水平展示的方法/","link":"","permalink":"https://xiaojinwen.github.io/2018/09/07/关于列表水平展示的方法/","excerpt":"","text":"一、使用float:left; 或 float:right这个方法水平排列起来简单 只需1float:left; 但是会引起一些不必要的问题: 父级盒子没有float部分的高度,因为float脱离了标准文档流解决办法可以设置父级的高,清理浮动,清理浮动的方式有很多,推荐使用伪类清理法123456789101112&lt;div class ='clearfix'&gt;&lt;/div&gt;.clearfix::after &#123; content: \".\"; clear: both; display: block; overflow: hidden; font-size: 0; height: 0;&#125;// 为兼容IE6,IE7，因为ie6,ie7不能用after伪类。加上下面代码.clearfix&#123;zoom:1&#125; 二、设置元素为行内块元素在需要水平排列的地方1display: inline-block; 三、使用flex布局在需要水平排列的父布局中 12display: flex;// flex-wrap: wrap; /*超出宽度强制换行*/ 在子布局中 12flex: 1;// 更多参数选择请自行百度 flex","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojinwen.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojinwen.github.io/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojinwen.github.io/categories/前端/"}]},{"title":"数组与字符串的那些相似方法","slug":"数组与字符串的那些相似方法","date":"2018-09-04T08:22:16.000Z","updated":"2018-09-04T10:14:08.623Z","comments":true,"path":"2018/09/04/数组与字符串的那些相似方法/","link":"","permalink":"https://xiaojinwen.github.io/2018/09/04/数组与字符串的那些相似方法/","excerpt":"","text":"一、字符串方法1、slice() 提取字符串的片断，并在新的字符串中返回被提取的部分。12345678stringObject.slice(start,end) // start 起始下标 负数时,从尾部开始算起位置: -1 最后,-2 倒数二// end 结束下标 省略时,表示到最后,负数时,同上// e.g.var str=\"Hello happy world!\"console.log(str.slice(6))// happy world! 2、substr() 从起始索引号提取字符串中指定数目的字符。(不建议使用 ECMAscript没有对该方法进行标准化)12345678stringObject.substr(start,length)// start 必须 起始下标,num 负数时,从尾部开始算起位置: -1 最后,-2 倒数二// length 可选 长度,num 省略时,表示到最后// e.g.var str=\"Hello world!\"console.log(str.substr(3))// lo world! 3、substring() 提取字符串中两个指定的索引号之间的字符。1234567891011stringObject.substring(start,stop)// start 必须 非负整 起始下标,num// stop 可选 非负整 比要提取位置+1 省略时,表示到最后// e.g.var str=\"Hello world!\"console.log(str.substring(3))console.log(str.substring(3,7))// lo world!// lo w 4、concat() 连接字符串。1234567stringObject.concat(stringX,stringX,...,stringX)// e.g.var str1=\"Hello \"var str2=\"world!\"console.log(str1.concat(str2))// Hello world! 5、split() 把字符串分割为字符串数组。123stringObject.split(separator,howmany)// separator 必需 字符串或正则 切割符号// howmany 可选 最大返回长度 省略忽视最大返回长度 注：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割注：String.split()与 Array.join 执行的操作是相反的 6、others1234567891011121314charAt() 返回在指定位置的字符。indexOf() 检索字符串。返回位置lastIndexOf() 从后向前搜索字符串。返回位置match() 找到一个或多个正则表达式的匹配。replace() 替换与正则表达式匹配的子串。search() 检索与正则表达式相匹配的值。sub() 把字符串显示为下标。sup() 把字符串显示为上标。toLocaleLowerCase() 把字符串转换为小写。toLocaleUpperCase() 把字符串转换为大写。toLowerCase() 把字符串转换为小写。toUpperCase() 把字符串转换为大写。toString() 返回字符串。valueOf() 返回某个字符串对象的原始值。 二、数组方法1、concat() 连接两个或更多的数组，并返回结果。1234567arrayObject.concat(arrayX,arrayX,......,arrayX)// e.g.var arr1=['hello'];var arr2=['world!'];console.log(arr1.concat(arr2))// ['Hello','world!'] 2、slice() 从某个已有的数组返回选定的元素(不修改原数组)1234567891011arrayObject.slice(start,end)// start 必需 起始下标 负数时,从尾部开始算起位置: -1 最后,-2 倒数二// end 可选 结束下标 省略时,表示到最后,负数时,同上// e.g.var arr=['thank','you','very','math'];console.log(arr.slice(2,3))console.log(arr)// ['very']// ['thank','you','very','math'] 3、splice() 删除元素，并向数组添加新元素(改变原数组)123456789101112arrayObject.splice(index,howmany,item1,.....,itemX)// index 必需 起始下标 负数时,从尾部开始算起位置: -1 最后,-2 倒数二// howmany 可选 删除数量 0:不删// item1,.....,itemX 可选 增加新项// e.g.var arr=['thank','you','very','math'];console.log(arr.splice(1,1,'xjw'))console.log(arr)// ['you']// ['thank','xjw','very','math'] 4、others123456789join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。pop() 删除并返回数组的最后一个元素push() 向数组的末尾添加一个或更多元素，并返回新的长度。shift() 删除并返回数组的第一个元素unshift() 向数组的开头添加一个或更多元素，并返回新的长度。reverse() 颠倒数组中元素的顺序。sort() 对数组的元素进行排序 注:a-b 正数换位置toString() 把数组转换为字符串，并返回结果。valueOf() 返回数组对象的原始值 三、字符串与数据都有的方法1.slice()2.concat()","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojinwen.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojinwen.github.io/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojinwen.github.io/categories/前端/"}]},{"title":"phpMyAdmin无法登陆解决","slug":"phpMyAdmin无法登陆解决","date":"2018-08-31T03:53:39.000Z","updated":"2018-08-31T05:08:33.735Z","comments":true,"path":"2018/08/31/phpMyAdmin无法登陆解决/","link":"","permalink":"https://xiaojinwen.github.io/2018/08/31/phpMyAdmin无法登陆解决/","excerpt":"","text":"问题ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: NO)ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES) 解析通常这种情况是没有设置密码或者密码错误导致的 解决首先确定 相关端口打开了 3306 888(默认) 1.关闭mysql 1/bin/systemctl stop mysql.service or1/etc/init.d/mysql stop 2.在mysql关闭的情况下： 1/bin/systemctl stop mysql.service --skip-grant-tables or1/etc/init.d/mysql start --skip-grant-tables 3.连接mysql,进入mysql命令行12345mysql -u root -p ## 出现password：的时候直接回车可以进入。mysql&gt; use mysql; Database changedmysql&gt; update user set password=password(\"123456\") where user=\"root\"; # 给root用户设置新密码mysql&gt; flush privileges; # 刷新数据库mysql&gt; quitBye # 退出mysql 改好之后,重启mysql服务就可以了。去掉这句 --skip-grant-tables","categories":[{"name":"后端","slug":"后端","permalink":"https://xiaojinwen.github.io/categories/后端/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://xiaojinwen.github.io/tags/后端/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://xiaojinwen.github.io/categories/后端/"}]},{"title":"使用canvas画环形进度条","slug":"使用canvas画环形进度条","date":"2018-08-30T11:07:06.000Z","updated":"2018-08-30T11:20:57.629Z","comments":true,"path":"2018/08/30/使用canvas画环形进度条/","link":"","permalink":"https://xiaojinwen.github.io/2018/08/30/使用canvas画环形进度条/","excerpt":"","text":"效果展示 html1234&lt;canvas id=\"myCanvas\" width=\"300\" height=\"150\" style=\"border:1px solid #d3d3d3;\"&gt; Your browser does not support the HTML5 canvas tag.&lt;/canvas&gt; js1234567891011121314151617181920212223242526let canvas = document.getElementById('myCanvas')let ctx = canvas.getContext('2d')// 绘制 灰色层 底层ctx.beginPath()ctx.arc(100, 75, 50, 0, 2 * Math.PI)ctx.lineWidth = 10ctx.strokeStyle = \"#eee\";ctx.stroke()// 绘制 蓝色层 进度层ctx.beginPath()ctx.arc(100, 75, 50, -Math.PI / 2, 0)ctx.lineWidth = 10ctx.strokeStyle = \"#489cff\";ctx.stroke()// 绘制文字层ctx.font = \"20px Verdana\";/* 渐变let gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);gradient.addColorStop(0, \"magenta\");gradient.addColorStop(0.5, \"blue\");gradient.addColorStop(1, \"red\");ctx.fillStyle = gradient;*/ctx.fillStyle = \"#666\";ctx.fillText(\"25%\", 80, 84)","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojinwen.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojinwen.github.io/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojinwen.github.io/categories/前端/"}]},{"title":"自定义百度云分享密码","slug":"自定义百度云分享密码","date":"2018-08-30T03:39:24.000Z","updated":"2018-08-30T11:20:08.919Z","comments":true,"path":"2018/08/30/自定义百度云分享密码/","link":"","permalink":"https://xiaojinwen.github.io/2018/08/30/自定义百度云分享密码/","excerpt":"","text":"动态图片展示 1javascript:require([&quot;function-widget-1:share/util/service/createLinkShare.js&quot;]).prototype.makePrivatePassword=function()&#123;return prompt(&quot;请输入自定义的密码&quot;,&quot;1234&quot;)&#125; 使用方法：首先，选择要分享的文件，点击分享按钮。这时候，按F12打开控制台，切换至Console，输入代码按回车即可。 然后点击创建私密链接，会弹出输入框，输入密码即可！ 注意使用代码前要先点一下分享按钮，相关模块才会载入，这时候用代码才有效果。 转载自:流年似水博客转载自:西门吹雪","categories":[{"name":"其他","slug":"其他","permalink":"https://xiaojinwen.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://xiaojinwen.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://xiaojinwen.github.io/categories/其他/"}]},{"title":"动态路由-路由访问权限","slug":"动态路由-路由访问权限","date":"2018-08-30T02:42:53.000Z","updated":"2018-08-30T09:43:42.000Z","comments":true,"path":"2018/08/30/动态路由-路由访问权限/","link":"","permalink":"https://xiaojinwen.github.io/2018/08/30/动态路由-路由访问权限/","excerpt":"","text":"动态路由控制权限 参考文章12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485login.vuelet dR = new Array();for (let i = 0; i &lt; dynamicRouter.length; i++) &#123; //第一层循环遍历动态路由表的每一个路由 let aside_list = this.aside_list for (let j = 0; j &lt; aside_list.length; j++) &#123; if (dynamicRouter[i].path === aside_list[j].path &amp;&amp; aside_list[j].isShow) &#123; // console.log(dynamicRouter[i]) dR.push(dynamicRouter[i]); // 符合条件的路由信息就放进数组里 if (!this.xjw) &#123; // this.firstShowPath = dynamicRouter[i] dR.push(dynamicRouter[2]); this.xjw = true &#125; &#125; else if (aside_list[j].path.indexOf('x') &amp;&amp; aside_list[j].isShow) &#123; if (!this.first) &#123; // 符合条件的路由的福袋必须访问的路由就放进数组里 dR.push(dynamicRouter[0]); dR.push(dynamicRouter[1]); this.first = true &#125; &#125; else if ( (aside_list[j].path.indexOf('xx') || aside_list[j].path.indexOf('xxx') || aside_list[j].path.indexOf('xxxx')) &amp;&amp; aside_list[j].isShow) &#123; if (!this.second) &#123; dR.push(dynamicRouter[1]); this.second = true &#125; &#125; &#125;&#125;this.xjw = nullthis.first = nullthis.second = null// console.log(dR)this.$router.addRoutes(dR.concat([&#123; //这里调用addRoutes方法，动态添加符合条件的路由 path: '*', redirect: '/404' //所有不匹配路径(*)都重定向到404，为什么写在这里而不放到静态路由表里可以查看“前端路上”的文章&#125;]));this.$router.push(this.firstShowPath); APP.vue// 获取登录状态if (!isLogin) &#123; return this.$router.push('/login');&#125; else &#123; let dR = new Array(); for (let i = 0; i &lt; dynamicRouter.length; i++) &#123; let aside_list = this.get_aside_list.aside_list // console.log(dynamicRouter[i]) for (let j = 0; j &lt; aside_list.length; j++) &#123; if (dynamicRouter[i].path === aside_list[j].path &amp;&amp; aside_list[j].isShow) &#123; // console.log(dynamicRouter[i]) dR.push(dynamicRouter[i]); //符合条件的路由信息就放进数组里 if (!this.xjw) &#123; dR.push(dynamicRouter[2]); this.xjw = true &#125; &#125; else if (aside_list[j].path.indexOf('x') &amp;&amp; aside_list[j].isShow) &#123; if (!this.first) &#123; dR.push(dynamicRouter[0]); dR.push(dynamicRouter[1]); this.first = true &#125; &#125; else if ( (aside_list[j].path.indexOf('xx') || aside_list[j].path.indexOf('xxx') || aside_list[j].path.indexOf('xxxx')) &amp;&amp; aside_list[j].isShow) &#123; if (!this.second) &#123; dR.push(dynamicRouter[1]); this.second = true &#125; &#125; &#125; &#125; this.xjw = null this.first = null this.second = null // console.log(dR) this.$router.addRoutes(dR);","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojinwen.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojinwen.github.io/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojinwen.github.io/categories/前端/"}]},{"title":"hexo 常用命令","slug":"hexo 常用命令","date":"2018-08-30T02:39:24.000Z","updated":"2018-08-31T05:30:55.470Z","comments":true,"path":"2018/08/30/hexo 常用命令/","link":"","permalink":"https://xiaojinwen.github.io/2018/08/30/hexo 常用命令/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 列出已安装依赖(局部/全局)12$ npm ls --depth 0 $ npm ls --depth 0 -g","categories":[{"name":"其他","slug":"其他","permalink":"https://xiaojinwen.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://xiaojinwen.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://xiaojinwen.github.io/categories/其他/"}]},{"title":"删除服务器乱码文件/目录","slug":"删除服务器乱码文件","date":"2018-08-30T02:20:58.000Z","updated":"2018-08-30T09:43:42.000Z","comments":true,"path":"2018/08/30/删除服务器乱码文件/","link":"","permalink":"https://xiaojinwen.github.io/2018/08/30/删除服务器乱码文件/","excerpt":"","text":"方法一1.使用 ls -li 命令得到乱码文件的 inode 值1$ ls -li 2.使用 find . -inum 24609 -exec rm {} -rf \\; 命令删除乱码文件.其中24609替换为乱码文件的inode值. 注意空格 中英文符号\\;等1$ find . -inum 24609 -exec rm &#123;&#125; -rf \\; 方法二1.使用rm -rf 删除上一级目录，当然前提是需要备份你需要备份的数据.123456789101112131415一种思路：1. 比如/home下文件夹内含有乱码的文件2. mkdir tmp3. 将所有的文件首先移动到 mv * tmp/4.到tmp下 把所有有正常的显示字符的文件移动出来cd tmp ;mv [a-zA-Z0-9]* ..5.现在可以 rm -rf tmp 了","categories":[{"name":"服务器","slug":"服务器","permalink":"https://xiaojinwen.github.io/categories/服务器/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://xiaojinwen.github.io/tags/服务器/"}],"keywords":[{"name":"服务器","slug":"服务器","permalink":"https://xiaojinwen.github.io/categories/服务器/"}]},{"title":"文件管理php","slug":"文件管理php","date":"2018-08-30T01:27:59.000Z","updated":"2018-08-30T09:43:42.000Z","comments":true,"path":"2018/08/30/文件管理php/","link":"","permalink":"https://xiaojinwen.github.io/2018/08/30/文件管理php/","excerpt":"","text":"有些代码不是自己写的 所以格式不太同123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273&lt;?phpfunction fileAdir($dir) &#123; if (!is_dir($dir))&#123; mkdir($dir); chmod($dir,0777); $data = scandir(&quot;$dir&quot;); $allFile = array(); foreach ($data as $file) &#123; if($file != &apos;.&apos; &amp;&amp; $file != &apos;..&apos;) &#123; //判断是否是文件夹内的文件夹 $a = array( &apos;file&apos;=&gt;$file, &apos;isDir&apos;=&gt;is_dir($dir. &apos;/&apos; .$file), &apos;name&apos;=&gt;$dir . &apos;/&apos; .$file ); array_push($allFile, $a); &#125; &#125; return $allFile; &#125; else&#123; $data = scandir(&quot;$dir&quot;); $allFile = array(); foreach ($data as $file) &#123; if($file != &apos;.&apos; &amp;&amp; $file != &apos;..&apos;) &#123; //判断是否是文件夹内的文件夹 $a = array( &apos;file&apos;=&gt;$file, &apos;isDir&apos;=&gt;is_dir($dir. &apos;/&apos; .$file), &apos;name&apos;=&gt;$dir . &apos;/&apos; .$file ); array_push($allFile, $a); &#125; &#125; return $allFile; &#125;&#125;/** 读取文件类 **/class file &#123; public $file; public $filename; //文件名字 public $filetype; //文件类型 public $filesize; //文件大小 public $fileopen; //打开文件 public $fileread; //读取文件 //写入变量 public $filepath; public $filecontent; //保存文件用到的文件内容 public $fileput; //文件写入 public function edits($files)&#123; $this-&gt;file = $files; if(!file_exists($this-&gt;file))&#123; die(&quot;文件不存在！&quot;); &#125; $this-&gt;fileopen = fopen($this-&gt;file, &apos;r&apos;); if(!$this-&gt;fileopen)&#123; die(&quot;文件读取失败&quot;); &#125; //$this-&gt;fileread = htmlspecialchars($this-&gt;fileread); //开始获取文件的后缀名 $filestr = strlen($this-&gt;file); $filepoint = strrpos($this-&gt;file, &apos;.&apos;); $filesub = substr($this-&gt;file, $filepoint+1); $this-&gt;filetype = $filesub; $this-&gt;filename = basename($this-&gt;file); $this-&gt;filesize = filesize($this-&gt;file); if($this-&gt;filesize===0)&#123; return array( &apos;filetype&apos;=&gt;$this-&gt;filetype, &apos;filename&apos;=&gt;$this-&gt;filename, &apos;filecontent&apos;=&gt;&apos;&apos;, &apos;filepath&apos;=&gt;$this-&gt;file ); exit; &#125; $this-&gt;fileread = fread($this-&gt;fileopen,$this-&gt;filesize); // 读取中文 //$this-&gt;fileread =iconv(&apos;gb2312&apos;, &apos;utf-8&apos;, $this-&gt;fileread); //以数组形式返回：文件类型 文件名称 文件内容 文件路径 return array( &apos;filetype&apos;=&gt;$this-&gt;filetype, &apos;filename&apos;=&gt;$this-&gt;filename, &apos;filecontent&apos;=&gt;$this-&gt;fileread, &apos;filepath&apos;=&gt;$this-&gt;file ); //关闭文件 fclose($this-&gt;file); &#125; /* 修改文件函数 */ public function bc($filepath,$filecontent)&#123; $this-&gt;filepath = $filepath; //访问文件 $this-&gt;fileopen = file_get_contents($this-&gt;filepath); if(!$this-&gt;fileopen)&#123; //die(&apos;文件打开失败&apos;); &#125; //获取传进来的文件内容 $this-&gt;filecontent = $filecontent; //反转义html //$this-&gt;filecontent = htmlspecialchars_decode($this-&gt;filecontent); //写入文件 $this-&gt;fileput = file_put_contents($this-&gt;filepath, $this-&gt;filecontent); if($this-&gt;fileput)&#123; return &apos;修改文件成功&apos;; &#125;else &#123; return &apos;修改文件失败&apos;; &#125; &#125; // 创建文件夹 public function create_folder($dir) &#123; if (!file_exists($dir))&#123; //mkdir($dir,0777,true); mkdir($dir); chmod($dir,0777); return &apos;创建文件夹成功&apos;; &#125; else &#123; return &apos;创建文件夹已存在&apos;; &#125; &#125; // 创建文件 public function create_file($dir) &#123; if (!file_exists($dir))&#123; $handle = fopen($dir, &apos;w&apos;); chmod($dir,0777); if($handle)&#123; return &apos;创建文件成功&apos;; &#125; else&#123; return &apos;创建文件失败&apos;; &#125; &#125; else &#123; return &apos;需创建的文件已经存在&apos;; &#125; &#125; // 重命名文件/文件夹 public function fileRename($old_name,$new_name) &#123; if(!file_exists($new_name)||file_exists($old_name))&#123; $result = rename($old_name,$new_name); if($result)&#123; return &apos;重命名成功&apos;; &#125; else&#123; return &apos;重命名失败&apos;; &#125; &#125; else &#123; return &apos;目标文件已存在或原文件不存在&apos;; &#125; &#125; // 复制文件夹及文件夹下文件 public function copyDirAndFile($src,$dst) &#123; // 原目录，复制到的目录 if(file_exists($src))&#123; $dir = opendir($src); @mkdir($dst); chmod($dst,0777); while(false !== ($file = readdir($dir))) &#123; if (( $file != &apos;.&apos; ) &amp;&amp; ( $file != &apos;..&apos; )) &#123; if (is_dir($src . &apos;/&apos; . $file)) &#123; $this-&gt;copyDirAndFile($src . &apos;/&apos; . $file,$dst . &apos;/&apos; . $file); chmod($dst . &apos;/&apos; . $file,0777); &#125; else &#123; copy($src . &apos;/&apos; . $file,$dst . &apos;/&apos; . $file); chmod($dst . &apos;/&apos; . $file,0777); &#125; &#125; &#125; closedir($dir); return true; &#125; else &#123; return false; &#125; &#125; // 删除文件夹及文件夹下文件 public function delDirAndFile($dirName)&#123; if(file_exists($dirName))&#123; if ($handle = opendir(&quot;$dirName&quot; )) &#123; while (false !== ($item=readdir($handle))) &#123; if ($item != &quot;.&quot; &amp;&amp; $item != &quot;..&quot;) &#123; if (is_dir( &quot;$dirName/$item&quot;)) &#123; $this-&gt;delDirAndFile( &quot;$dirName/$item&quot; ); &#125; else &#123; if(unlink( &quot;$dirName/$item&quot; ))&#123; // echo &quot;成功删除文件： $dirName/$item\\n&quot;; &#125; &#125; &#125; &#125; closedir( $handle ); if(rmdir( $dirName )) &#123; // echo &quot;成功删除目录： $dirName\\n&quot;; &#125; &#125; return true; &#125; else&#123; return false; &#125; &#125; // 剪切文件夹及文件夹下文件 public function cutDirAndFile($src,$dst) &#123; // 原目录，复制到的目录 if(file_exists($src))&#123; $dir = opendir($src); @mkdir($dst); chmod($dst,0777); while(false !== ($file = readdir($dir))) &#123; if (( $file != &apos;.&apos; ) &amp;&amp; ( $file != &apos;..&apos; )) &#123; if (is_dir($src . &apos;/&apos; . $file)) &#123; $this-&gt;copyDirAndFile($src . &apos;/&apos; . $file,$dst . &apos;/&apos; . $file); chmod($dst . &apos;/&apos; . $file,0777); &#125; else &#123; copy($src . &apos;/&apos; . $file,$dst . &apos;/&apos; . $file); chmod($dst . &apos;/&apos; . $file,0777); //unlink($src . &apos;/&apos; . $file); &#125; &#125; &#125; $file = new file(); $delete = $file-&gt;delDirAndFile($src); if(!$delete)&#123; return &apos;文件夹删除失败&apos;; &#125; $file = null; closedir($dir); return true; &#125; else &#123; return false; &#125; &#125; // 复制单个文件 public function fileCopy($source_name,$target_name) &#123; if(!file_exists($target_name)||file_exists($source_name))&#123; //return copy($source_name,$target_name)?true:false; $result = copy($source_name,$target_name); chmod($target_name,0777); return $result; if($result)&#123; return &apos;复制文件成功&apos;; &#125; else &#123; return &apos;复制文件失败&apos;; &#125; &#125; else &#123; return &apos;目标文件已经存在或者原始文件不存在&apos;; &#125; &#125; // 删除单个文件 public function fileDelete($del_name) &#123; if(file_exists($del_name))&#123; $result = unlink($del_name); if($result)&#123; return &apos;删除文件成功&apos;; &#125; else &#123; return &apos;删除文件失败&apos;; &#125; &#125; else &#123; return &apos;要删除的文件不存在&apos;; &#125; &#125; // 剪切单个文件 public function fileCut($source_name,$target_name) &#123; if(!file_exists($target_name)||file_exists($source_name))&#123; //return copy($source_name,$target_name)?true:false; $result = copy($source_name,$target_name); chmod($target_name,0777); unlink($source_name); if($result)&#123; return &apos;剪切文件成功&apos;; &#125; else &#123; return &apos;剪切文件失败&apos;; &#125; &#125; else &#123; return &apos;目标文件已经存在或者原始文件不存在&apos;; &#125; &#125;&#125;?&gt;","categories":[{"name":"后端","slug":"后端","permalink":"https://xiaojinwen.github.io/categories/后端/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://xiaojinwen.github.io/tags/后端/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://xiaojinwen.github.io/categories/后端/"}]}]}