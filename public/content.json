{"meta":{"title":"个人博客-xiaojinwen","subtitle":"xiaojinwen","description":"个人日常","author":"xiaojinwen","url":"https://xiaojw.xyz"},"pages":[],"posts":[{"title":"fixed定位失效问题","slug":"fixed定位失效问题","date":"2020-06-11T14:00:49.000Z","updated":"2020-07-08T03:16:11.095Z","comments":true,"path":"2020/06/11/fixed定位失效问题/","link":"","permalink":"https://xiaojw.xyz/2020/06/11/fixed定位失效问题/","excerpt":"","text":"问题 父元素使用transform,子元素使用fixed定位会失效, 解决方法一 父元素不适用transform属性或者子元素不使用fixed定位 方法二 方法一无法解决(可能父元素是使用的某些插件,或者子元素不适用fixed无法实现效果) 将子元素剥离出有transform属性的父元素,再使用fixed","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"使用lodash所遇问题之(vue)this指向出错","slug":"使用lodash所遇问题之(vue)this指向出错","date":"2020-06-11T14:00:49.000Z","updated":"2020-07-08T03:00:01.187Z","comments":true,"path":"2020/06/11/使用lodash所遇问题之(vue)this指向出错/","link":"","permalink":"https://xiaojw.xyz/2020/06/11/使用lodash所遇问题之(vue)this指向出错/","excerpt":"","text":"问题 lodash库,使用节流/防抖 使用箭头函数 this指向出错 解决方法123456789101112131415161718// 这样写this指向会错误methods:&#123; resize: _.throttle(()=&gt;&#123; // this.xxx 出错 &#125;, 1000),&#125;// 应该这样methods:&#123; resize: _.throttle(function()&#123; // this.xxx 正常 &#125;, 1000),&#125;// 或者created() &#123; this.resize = _.throttle(this.resize, 300); window.addEventListener('resize', this.resize); // 此处省略remove&#125;,methods:&#123; resize()&#123; // this.xxx 正常 &#125;,&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"快应用卡片absolute定位失效问题","slug":"快应用卡片absolute定位失效问题","date":"2020-06-11T14:00:49.000Z","updated":"2020-07-08T03:50:54.514Z","comments":true,"path":"2020/06/11/快应用卡片absolute定位失效问题/","link":"","permalink":"https://xiaojw.xyz/2020/06/11/快应用卡片absolute定位失效问题/","excerpt":"","text":"需求一 页面是要求将一个浏览数量显示在列表每个item的下方位置,我很自然的使用了绝对定位,快应用里显示是完全正常的, 问题然而预览卡片的时候就出现怪事了,布局错乱了,布局很简单,所以我一下就觉得是绝对定位失效的问题(当时不知道怎么打开element,所以完全是靠改代码然后定位问题,后来知道了,在快应用开发工具-调试器-DEVTOOLS-右上角的三个点,然后点击Run command-输入show Elements执行,就可以看到页面的结构了),定位失效有可能是因为快应用本身是全局使用的flex布局,也有可能是快应用卡片暂不支持使用绝对定位 解决因为快应用使用的是flex布局,所以使用flex布局的属性解决问题,是我最优先想到的. 使用flex属性解决tips:此处都省略设置display:flex; 父元素使用12flex-direction: column;justify-content: space-between; 子元素(居上的)因为我上方是一个两行(或者一行)文字的标题12345lines: 2;text-overflow: ellipsis;/* 居上显示 不要设置高度 */align-self: flex-start;line-height: 60px; 子元素(居下的)这个不用设置flex的属性 需求二 页面需要list的每一个item的一个图片的右下方显示一个文本 使用flex属性和margin属性图片的样式正常设置宽度,高度铺满整个容器 在图片右下角显示的文本123margin-left: -132px;align-self: flex-end;margin-bottom: 16px; 成功解决","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"完整的下载例子(node&js)","slug":"完整的下载例子(node&js)","date":"2020-06-11T14:00:49.000Z","updated":"2020-07-08T04:11:15.850Z","comments":true,"path":"2020/06/11/完整的下载例子(node&js)/","link":"","permalink":"https://xiaojw.xyz/2020/06/11/完整的下载例子(node&js)/","excerpt":"","text":"完整的下载例子(node&amp;js)接口正常返回,content 字段内容为下载文件的 Buffer 数据 node(think.js)重新加载了一个未设置宽度的的图片 取出图片的宽高 123456789101112131415161718192021...省略部分const fs = require(\"fs\");const path = `./export/$&#123;fileName + suffix&#125;`;const &#123; ctx &#125; = this;const reader = fs.createReadStream(path);const streamToBuffer = (stream) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const buffers = []; stream.on(\"error\", reject); stream.on(\"data\", (data) =&gt; buffers.push(data)); stream.on(\"end\", () =&gt; resolve(Buffer.concat(buffers))); &#125;);&#125;;const content = await streamToBuffer(reader);return ctx.success(&#123; content, // mime_type: 'text/comma-separated-values', mime_type: \"text/csv\", fileName, suffix,&#125;); node(think.js)1234567891011121314151617181920212223242526...省略部分// let ab = new ArrayBuffer(data.content.data.length);// let view = new Uint8Array(ab);// for (var i = 0; i &lt; data.content.data.length; ++i) &#123;// view[i] = data.content.data[i];// &#125;// console.log(view);const ab = Buffer.from(data.content, \"binary\");const blob = new Blob([ab], &#123; type: data.mime_type,&#125;);const fileName = data.fileName + data.suffix || \"unkown\";if (window.navigator.msSaveOrOpenBlob) &#123; navigator.msSaveBlob(blob, fileName);&#125; else &#123; const link = document.createElement(\"a\"); const body = document.querySelector(\"body\"); link.href = window.URL.createObjectURL(blob); // 创建对象url link.download = fileName; // fix Firefox link.style.display = \"none\"; body.appendChild(link); link.click(); body.removeChild(link); window.URL.revokeObjectURL(link.href); // 通过调用 URL.createObjectURL() 创建的 URL 对象&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"},{"name":"后端","slug":"前端/后端","permalink":"https://xiaojw.xyz/categories/前端/后端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"},{"name":"后端","slug":"前端/后端","permalink":"https://xiaojw.xyz/categories/前端/后端/"}]},{"title":"获取图片原始宽高","slug":"获取图片原始宽高","date":"2020-06-11T14:00:49.000Z","updated":"2020-07-08T03:57:49.979Z","comments":true,"path":"2020/06/11/获取图片原始宽高/","link":"","permalink":"https://xiaojw.xyz/2020/06/11/获取图片原始宽高/","excerpt":"","text":"问题某些场景下数据库中储存的图片的宽高度和图片真实的宽高度不同,直接使用数据库的宽高设置样式就会出现图片被拉伸或者被压缩 解决重新加载了一个未设置宽度的的图片 取出图片的宽高1234567891011121314imgLoad(url) &#123; return new Promise((resolve, reject) =&gt; &#123; let img = new Image(); img.src = url; if (img.complete) &#123; resolve(&#123;width:img.width,height:img.height,&#125;); &#125; else &#123; img.onload = function() &#123; resolve(&#123;width:img.width,height:img.height,&#125;); img.onload = null; &#125;; &#125; &#125;);&#125;, 成功解决","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"字体抖动问题","slug":"字体抖动问题","date":"2020-06-11T13:55:49.000Z","updated":"2020-07-08T02:55:13.413Z","comments":true,"path":"2020/06/11/字体抖动问题/","link":"","permalink":"https://xiaojw.xyz/2020/06/11/字体抖动问题/","excerpt":"","text":"原因及解决方法页面元素显示隐藏引起页面重绘,重排,而显示字体的元素中没有设置高度/行高或者绝对定位的没有设置top,right,bottom,left,4个方向的值","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"解决移动端字体不能垂直居中","slug":"解决移动端字体不能垂直居中","date":"2020-04-12T16:23:36.000Z","updated":"2020-07-08T02:45:38.120Z","comments":true,"path":"2020/04/13/解决移动端字体不能垂直居中/","link":"","permalink":"https://xiaojw.xyz/2020/04/13/解决移动端字体不能垂直居中/","excerpt":"","text":"问题最近遇到块状元素设置height以及line-height相同竟然不是垂直居中的问题, 查了下资料说是字体大小设置不是偶数的问题 但是项目中使用了rem 奇数比较难避免,目前有三种解决方法 解决1、字体和line-height,height 设置大一倍 在用css3缩小一倍1234line-height: 44px;height-height: 44px;font-size: 24px;transform : scale(0.5); 2、line-height设置为1,设置相同的上下padding1234line-height: 24px;font-size: 12px;padding-top: 6px;padding-bottom: 6px; 3、设置1像素的透明border,盒模型改为border-box12345height: xrem;line-height: xrem;font-size: xxrem;border: 1px solid transparent;box-sizing: border-box;","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"页面切换关闭未完成的axios请求","slug":"页面切换关闭未完成的axios请求","date":"2020-03-11T02:52:49.000Z","updated":"2020-07-08T02:45:38.120Z","comments":true,"path":"2020/03/11/页面切换关闭未完成的axios请求/","link":"","permalink":"https://xiaojw.xyz/2020/03/11/页面切换关闭未完成的axios请求/","excerpt":"","text":"实现使用axios拦截器 123456789101112131415161718192021222324252627282930313233343536373839// ...import// 获取CancelTokenconst CancelToken = axios.CancelToken;let cancel = [];// http request 拦截器);axios.interceptors.request.use( (config) =&gt; &#123; // 全局添加cancelToken config.cancelToken = new CancelToken(c =&gt; &#123; //强行中断请求要用到的 cancel.push(c) &#125;) return config; &#125;, (err) =&gt; &#123; return Promise.reject(err); &#125;,);// http response 拦截器axios.interceptors.response.use((response) =&gt; &#123; return Promise.resolve(response);&#125;, (error) =&gt; &#123; if (axios.isCancel(error)) &#123; // 取消请求的情况下，终断Promise调用链 return new Promise(() =&gt; &#123; &#125;); &#125; else &#123; return Promise.reject(error); &#125;&#125;);Vue.prototype.$cancelAjax = () =&gt; &#123; // 关闭上一次axios请求的方法 cancel.forEach(item =&gt; item()) cancel = []&#125;// 页面切换前时候执行 $cancelAjax 方法","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"antdesign实现select框懒加载","slug":"antdesign实现select框懒加载","date":"2019-12-23T02:52:49.000Z","updated":"2020-07-08T02:45:38.089Z","comments":true,"path":"2019/12/23/antdesign实现select框懒加载/","link":"","permalink":"https://xiaojw.xyz/2019/12/23/antdesign实现select框懒加载/","excerpt":"","text":"select框 还可以搜索 实现原理即是手动去修改option的长度 将所有的option保存起来 首次显示默认条数 当select框选择内容滚动到底部 再增加条数 输入搜索内容时 清空之前的option 替换为搜索匹配到的新option(不要去重新赋值一个数组，而是修改原来的数组) 已知问题 initialValue值存在时会导致首次下拉选择框滚动到底部 加载更多option时的滚动条位置错误 不完美的解决 push数据前先清楚 initialValue值 操作完再恢复 副作用 滚动到底部后select框的值会清空了 失焦后才恢复 参考文章 https://www.cnblogs.com/clairelss/p/11063808.html1234567891011121314151617181920212223242526272829// 这是封装的组件 我拆出来了一部分// template 部分&lt;a-select allowClear v-if=\"item.type == 'select'||item.type == 'multiple'\" :getPopupContainer=\"triggerNode =&gt; triggerNode.parentNode\" :mode=\"item.type == 'multiple'?'multiple':undefined\" :showSearch=\"item.showSearch\" v-decorator=\"[ `$&#123;item.decorator&#125;`, &#123; rules: [&#123; required: item.required, message: `$&#123;item.Tips&#125; field should be no-null`, &#125;,...(item.rules &amp;&amp; item.rules instanceof Array ? item.rules : [])], initialValue:item.initialValue || undefined &#125; ]\" :placeholder=\"item.isShowPlaceHolder?item.Tips:''\" @change=\"handleInputChange($event,item.decorator)\" :disabled=\"item.disabled\" @popupScroll=\"selectScroll($event,item)\" @search=\"fetchSelectSearchData($event,item)\" @dropdownVisibleChange=\"SelectDropdownVisibleChange($event,item)\"&gt;&lt;a-select-option :value=\"child.value\" v-for=\"(child,key) in item.options\" :key=\"key\" :disabled=\"child.disabled\"&gt;&#123;&#123;child.name&#125;&#125;&lt;/a-select-option&gt;&lt;/a-select&gt; 上面要看的主要是123@popupScroll=&quot;selectScroll($event,item)&quot;@search=&quot;fetchSelectSearchData($event,item)&quot;@dropdownVisibleChange=&quot;SelectDropdownVisibleChange($event,item)&quot; 这三个回调 其他的不用看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122 // script部分 mixin.tsimport &#123; Vue, Component &#125; from 'vue-property-decorator'import &#123; deepClone, isObject, distinct&#125; from '@/assets/ts';declare module 'vue/types/vue' &#123; interface Vue &#123; timerId: number; // 用于防抖 解决输入框快速输入卡顿 dataLen: number; // 数据每次加载的条数 allOptionsDatakey: symbol; // 保存所有数据的 key isReady: symbol; // 用于判断数据是否被自己修改过 searchValue: any; // 上一次输入框输入的值 originOptions: any[]; // 保存修改过的option getSelectSearchDataList(item: any, value?: any): void; // 处理搜索和滚动时的数据 selectScroll(e: any, item: any): void; // select滚动时调用 @popupScroll回调 fetchSelectSearchData(value: any, item: any): void; // 输入内容搜索时调用 @search回调 SelectDropdownVisibleChange(e: any, item: any): void; // select内容选择框显示时调用 @dropdownVisibleChange回调 &#125;&#125;@Componentexport default class selecctMixin extends Vue &#123; /*** * select 懒加载 开始 * 实现原理即是 手动去修改option的长度 * * 将所有的option保存起来 (SelectDropdownVisibleChange) * 首次显示默认条数 * 当select框选择内容滚动到底部 再增加条数(不要去重新赋值一个数组，而是修改原来的数组) * 输入搜索内容时 清空之前的option 替换为搜索匹配到的新option * * 已知问题 initialValue值存在时会导致首次下拉选择框滚动到底部 加载更多option时的滚动条位置错误 * 不完美的解决 push数据前先清楚 initialValue值 操作完再恢复 * 副作用 滚动到底部后select框的值会清空了 失焦后才恢复 */ timerId: number = 0; // 用于防抖 解决输入框快速输入卡顿 dataLen: number = 100; // 数据每次加载的条数 allOptionsDatakey: symbol = Symbol.for(\"allOptionsDatakey\"); // 保存所有数据的 key isReady: symbol = Symbol.for(\"isReady\"); // 用于判断数据是否被自己修改过 searchValue: any; // 上一次输入框输入的值 originOptions: any[] = []; // 保存修改过的option // select滚动时调用 selectScroll(e: any, item: any) &#123; const &#123; target &#125; = e; if (target.scrollTop + target.offsetHeight === target.scrollHeight) &#123; item.scrollPage = item.scrollPage ? item.scrollPage + 1 : 1; this.getSelectSearchDataList(item, this.searchValue); // 调用处理数据方法 &#125; &#125; // 输入内容搜索时调用 fetchSelectSearchData(value: any, item: any) &#123; if (this.timerId) &#123; clearTimeout(this.timerId); &#125; this.timerId = setTimeout(() =&gt; &#123; item.scrollPage = 0; this.getSelectSearchDataList(item, value); // 调用处理数据方法 this.searchValue = value; &#125;, 300); &#125; // 处理搜索和滚动时的数据 getSelectSearchDataList(item: any, searchValue?: any) &#123; const start: number = item.scrollPage ? item.scrollPage * this.dataLen : 0; const end: number = item.scrollPage ? (item.scrollPage + 1) * this.dataLen : this.dataLen; // console.log(\"start\", start); // console.log(\"end\", end); const allOptions: any[] = deepClone(item[this.allOptionsDatakey]) const filterOption: any[] = searchValue ? [] : allOptions; // 执行 清空initialValue值之后 push完数据后再恢复原本值 原因是该值存在时会导致首次下拉选择框滚动到底部 加载更多option时的滚动条位置错误 如果没有这种问题可以不做此操作 const initialValue: any = item.initialValue item.initialValue = undefined if (searchValue) &#123; for (let innerItem of allOptions) &#123; new RegExp(searchValue, \"ig\").test( isObject(innerItem) ? innerItem.value : innerItem ) &amp;&amp; filterOption.push(innerItem); &#125; &#125; // 修改过输入框时 options清空 this.searchValue !== searchValue &amp;&amp; item.options.splice(0); filterOption.slice(start, end).length &amp;&amp; item.options.push(...filterOption.slice(start, end)); this.$nextTick(() =&gt; &#123; item.initialValue = initialValue &#125;) &#125; // select内容选择框显示时调用 SelectDropdownVisibleChange(visible: any, item: any) &#123; if (!item[this.isReady]) &#123; // 把所有的数据保存起来 并且标记状态 item[this.isReady] = true; item[this.allOptionsDatakey] = deepClone(distinct(item.options)); this.originOptions.push(item) &#125; // options赋值 this.dataLen 条数据 item.options = deepClone(item[this.allOptionsDatakey]).slice(0, this.dataLen) if (!visible) &#123; item.scrollPage = undefined; this.searchValue = undefined; &#125; &#125; public beforeDestroy() &#123; // 恢复默认值 this.originOptions.forEach((item: any) =&gt; &#123; if (item[this.isReady]) &#123; item.options = deepClone(item[this.allOptionsDatakey]) delete item[this.allOptionsDatakey] delete item[this.isReady] &#125; &#125;); this.originOptions = [] &#125; // select 懒加载结束&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"vue-cli3-配cdn","slug":"vue-cli3-配cdn","date":"2019-04-01T07:57:50.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2019/04/01/vue-cli3-配cdn/","link":"","permalink":"https://xiaojw.xyz/2019/04/01/vue-cli3-配cdn/","excerpt":"","text":"一、chainWebpack12345678910111213141516171819202122232425262728293031const cdn = &#123; css: [ 'https://cdn.xxxx.com/cdn/element-ui/2.7.0/index.css', 'https://cdn.xxxx.com/cdn/quill/1.3.6/quill.snow.min.css', 'https://cdn.xxxx.com/cdn/quill/1.3.6/quill.core.min.css', 'https://cdn.xxxx.com/cdn/quill/1.3.6/quill.bubble.min.css', ], js: [ 'https://cdn.xxxx.com/cdn/vue/2.6.10/vue.min.js', 'https://cdn.xxxx.com/cdn/element-ui/2.7.0/index.js', 'https://cdn.xxxx.com/cdn/vue-router/3.0.2/vue-router.min.js', 'https://cdn.xxxx.com/cdn/moment/2.6.10/moment.min.js', 'https://cdn.xxxx.com/cdn/vuex/3.1.0/vuex.min.js', 'https://cdn.xxxx.com/cdn/vue-i18n/8.9.0/vue-i18n.min.js', 'https://cdn.xxxx.com/cdn/lodash/4.17.11/lodash.min.js', 'https://cdn.xxxx.com/cdn/antv-g2/3.4.10/g2.min.js', 'https://cdn.xxxx.com/cdn/axios/0.18.0/axios.min.js', 'https://cdn.xxxx.com/cdn/quill/1.3.6/quill.min.js', ]&#125;module.exports =&#123; chainWebpack: config=&gt;&#123; if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置...process.env.NODE_ENV !== 'development' config.plugin('html') .tap(args =&gt; &#123; args[0].cdn = cdn; return args; &#125;) &#125; &#125;&#125; 二、configureWebpack12345678910111213141516171819module.exports =&#123; configureWebpack: config=&gt;&#123; if (process.env.NODE_ENV === 'production') &#123; // 'vue': 'Vue', key值需要去源代码里面找export config.externals = &#123; 'vue': 'Vue', 'vue-router': 'VueRouter', 'moment': 'moment', 'vuex': 'Vuex', 'element-ui': 'ELEMENT', 'lodash': '_', 'vue-i18n': 'VueI18n', '@antv/g2': 'G2_3', 'axios': 'axios', 'quill': 'Quill', &#125; &#125; &#125;&#125; 三、修改 public/index.html123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt; &lt;title&gt;管理系统&lt;/title&gt; &lt;!-- 使用CDN的CSS文件 --&gt; &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp; htmlWebpackPlugin.options.cdn.css) &#123; %&gt; &lt;link href=\"&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;\" rel=\"external nofollow\" rel=\"external nofollow\" rel=\"preload\" as=\"style\"&gt; &lt;link href=\"&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;\" rel=\"external nofollow\" rel=\"external nofollow\" rel=\"stylesheet\"&gt; &lt;% &#125; %&gt; &lt;!-- 使用CDN的JS文件 --&gt; &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp; htmlWebpackPlugin.options.cdn.js) &#123; %&gt; &lt;link href=\"&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;\" rel=\"external nofollow\" rel=\"preload\" as=\"script\"&gt; &lt;% &#125; %&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong&gt;We're sorry but 后台管理系统 doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;!-- 使用CDN的JS文件 --&gt; &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp; htmlWebpackPlugin.options.cdn.js) &#123; %&gt; &lt;script src=\"&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;\"&gt;&lt;/script&gt; &lt;% &#125; %&gt; &lt;/body&gt;&lt;/html&gt; 关于vue-cli3热更新失效的 只需要把css分离插件 注释掉 便可解决css: { extract: true} 附上vue-cli3 vue.config.js 完整配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184const path = require('path');// const vConsolePlugin = require('vconsole-webpack-plugin'); // 引入 移动端模拟开发者工具 插件 （另：https://github.com/liriliri/eruda）// const CompressionPlugin = require('compression-webpack-plugin'); //Gzip// const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; //Webpack包文件分析器// const baseUrl = process.env.NODE_ENV === \"production\" ? \"/static/\" : \"/\"; //font scss资源路径 不同环境切换控制const UglifyJsPlugin = require('uglifyjs-webpack-plugin');function resolve(dir) &#123; return path.join(__dirname, dir);&#125;const date = new Date()const appendPath = `$&#123;date.getFullYear()&#125;/$&#123;date.getMonth() + 1&#125;/$&#123;date.getDate()&#125;/`const cdn = &#123; css: [ 'https://cdn.xxxx.com/cdn/element-ui/2.7.0/index.css', 'https://cdn.xxxx.com/cdn/quill/1.3.6/quill.snow.min.css', 'https://cdn.xxxx.com/cdn/quill/1.3.6/quill.core.min.css', 'https://cdn.xxxx.com/cdn/quill/1.3.6/quill.bubble.min.css', ], js: [ 'https://cdn.xxxx.com/cdn/vue/2.6.10/vue.min.js', 'https://cdn.xxxx.com/cdn/element-ui/2.7.0/index.js', 'https://cdn.xxxx.com/cdn/vue-router/3.0.2/vue-router.min.js', 'https://cdn.xxxx.com/cdn/moment/2.6.10/moment.min.js', 'https://cdn.xxxx.com/cdn/vuex/3.1.0/vuex.min.js', 'https://cdn.xxxx.com/cdn/vue-i18n/8.9.0/vue-i18n.min.js', 'https://cdn.xxxx.com/cdn/lodash/4.17.11/lodash.min.js', 'https://cdn.xxxx.com/cdn/antv-g2/3.4.10/g2.min.js', 'https://cdn.xxxx.com/cdn/axios/0.18.0/axios.min.js', 'https://cdn.xxxx.com/cdn/quill/1.3.6/quill.min.js', ]&#125;module.exports = &#123; //基本路径 publicPath baseUrl publicPath: process.env.NODE_ENV === 'production' &amp;&amp; process.env.APP_PATH ? process.env.APP_PATH + appendPath : '/', indexPath: './index.html', //输出文件目录 outputDir: './dist', // eslint-loader 是否在保存的时候检查 lintOnSave: false, // lintOnSave: process.env.NODE_ENV !== 'production', //放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。 assetsDir: 'static', //以多页模式构建应用程序。 pages: undefined, //是否使用包含运行时编译器的 Vue 构建版本 runtimeCompiler: false, //是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建，在适当的时候开启几个子进程去并发的执行压缩 parallel: require('os').cpus().length &gt; 1, //生产环境是否生成 sourceMap 文件，一般情况不建议打开 productionSourceMap: false, // webpack配置 //对内部的 webpack 配置进行更细粒度的修改 https://github.com/neutrinojs/webpack-chain see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md chainWebpack: config =&gt; &#123; /** * 删除懒加载模块的prefetch，降低带宽压力 * https://cli.vuejs.org/zh/guide/html-and-static-assets.html#prefetch * 而且预渲染时生成的prefetch标签是modern版本的，低版本浏览器是不需要的 */ config.plugins.delete('prefetch'); if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置...process.env.NODE_ENV !== 'development' config.plugin('html') .tap(args =&gt; &#123; args[0].cdn = cdn; return args; &#125;) &#125; config.resolve.alias .set(\"vue$\", \"vue/dist/vue.esm.js\") .set(\"@\", resolve(\"src\")) .set(\"src\", resolve(\"src\")) .set(\"assets\", resolve(\"src/assets\")) .set(\"components\", resolve(\"src/components\")) .set(\"pages\", resolve(\"src/pages\")) .set(\"base\", resolve(\"src/components/base\")) .set(\"Common\", resolve(\"src/components/Common\")); &#125;, //调整 webpack 配置 https://cli.vuejs.org/zh/guide/webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; config.externals = &#123; 'vue': 'Vue', 'vue-router': 'VueRouter', 'moment': 'moment', 'vuex': 'Vuex', 'element-ui': 'ELEMENT', 'lodash': '_', 'vue-i18n': 'VueI18n', '@antv/g2': 'G2_3', 'axios': 'axios', 'quill': 'Quill', &#125; // 以及修改 public/index.html &#125; //生产and测试环境 let pluginsPro = [ // new CompressionPlugin(&#123; //文件开启Gzip，也可以通过服务端(如：nginx)(https://github.com/webpack-contrib/compression-webpack-plugin) // filename: '[path].gz[query]', // algorithm: 'gzip', // // test: new RegExp('\\\\.(' + ['js', 'css'].join('|') + ')$',), // test: new RegExp('\\\\.(js|css)$',), // threshold: 8192, // minRatio: 0.8, // &#125;), // Webpack包文件分析器(https://github.com/webpack-contrib/webpack-bundle-analyzer) // new BundleAnalyzerPlugin(), // 添加自定义代码压缩配置 压缩影响打包速度,增加访问速度 new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_debugger: true, drop_console: true, &#125;, &#125;, sourceMap: false, parallel: true, &#125;) ]; //开发环境 /*let pluginsDev = [ //移动端模拟开发者工具(https://github.com/diamont1001/vconsole-webpack-plugin https://github.com/Tencent/vConsole) new vConsolePlugin(&#123; filter: [], // 需要过滤的入口文件 enable: true // 发布代码前记得改回 false &#125;), ];*/ if (process.env.NODE_ENV === 'production') &#123; config.plugins = [...config.plugins, ...pluginsPro]; &#125; else &#123; // 为开发环境修改配置... // config.plugins = [...config.plugins, ...pluginsDev]; &#125; &#125;, css: &#123; // 启用 CSS modules modules: false, // 是否使用css分离插件 注釋掉 解决热更新失效问题 // extract: true, // 开启 CSS source maps，一般不建议开启 sourceMap: false, // css预设器配置项 loaderOptions: &#123; sass: &#123; //设置css中引用文件的路径，引入通用使用的scss文件（如包含的@mixin） data: `$baseUrl:\"/\";` // @import '@/assets/scss/_common.scss'; //data: `$baseUrl: \"/\";` &#125; &#125; &#125;,// webpack-dev-server 相关配置 https://webpack.js.org/configuration/dev-server/ devServer: &#123; host: \"0.0.0.0\", //localhost port: 8910, // 端口号 https: false, // https:&#123;type:Boolean&#125; open: false, // 配置自动启动浏览器 hotOnly: true, // 热更新 // proxy: 'http://localhost:8000' // 配置跨域处理,只有一个代理 /*proxy: &#123; //配置自动启动浏览器 \"/rest/!*\": &#123; target: \"http://172.16.1.12:7071\", changeOrigin: true, // ws: true,//websocket支持 secure: false &#125; &#125;*/ &#125;,// 第三方插件配置 https://www.npmjs.com/package/vue-cli-plugin-style-resources-loader pluginOptions: &#123; 'style-resources-loader': &#123;//https://github.com/yenshih/style-resources-loader preProcessor: 'scss',//声明类型 'patterns': [ //path.resolve(__dirname, './src/assets/scss/_common.scss'), ], //injector: 'append' &#125; &#125;&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"vue引入外部js","slug":"vue引入外部js","date":"2019-01-24T02:26:18.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2019/01/24/vue引入外部js/","link":"","permalink":"https://xiaojw.xyz/2019/01/24/vue引入外部js/","excerpt":"","text":".vue文件12345678910111213&lt;template&gt; &lt;div&gt; &lt;remote-script src=&quot;http://vip.niukewang.com/static/niu/js/ksbaoname.js&quot;&gt;&lt;/remote-script&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; mounted() &#123; // 外部js里的变量 console.log(listlei) &#125; &#125;&lt;/script&gt; main.js123456789101112131415161718192021222324252627282930313233// 导入外部jsimport Vue from 'vue' Vue.component('remote-script', &#123; render: function (createElement) &#123; var self = this; return createElement('script', &#123; attrs: &#123; type: 'text/javascript', src: this.src &#125;, on: &#123; load: function (event) &#123; self.$emit('load', event); &#125;, error: function (event) &#123; self.$emit('error', event); &#125;, readystatechange: function (event) &#123; if (this.readyState == 'complete') &#123; self.$emit('load', event); &#125; &#125; &#125; &#125;); &#125;, props: &#123; src: &#123; type: String, required: true &#125; &#125;&#125;); 文件转载自vue 引入外部js文件 - 配置component","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"vue-element-控制字段排序与显示小组件","slug":"vue-element-控制字段排序与显示小组件","date":"2019-01-04T07:32:38.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2019/01/04/vue-element-控制字段排序与显示小组件/","link":"","permalink":"https://xiaojw.xyz/2019/01/04/vue-element-控制字段排序与显示小组件/","excerpt":"","text":"效果 代码table-column.vue12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;el-table-column v-if=&quot;selection&quot; type=&quot;selection&quot; width=&quot;50&quot; fixed=&quot;left&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column v-for=&quot;(item,index) in list&quot; v-if=&quot;item.show&quot; :prop=&quot;item.prop&quot; :label=&quot;item.label&quot; :min-width=&quot;item.width&quot; :fixed=&quot;index===0&quot;&gt; &lt;template scope=&quot;scope&quot;&gt; &lt;div v-if=&quot;item.prop===&apos;rz&apos;&quot; :style=&quot;&#123;minWidth:item.width&#125;&quot;&gt; &lt;/div&gt; &lt;div v-else :style=&quot;&#123;minWidth:item.width&#125;&quot;&gt;&#123;&#123;scope.row[item.prop]&#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; list: Array, selection: Boolean &#125; &#125;&lt;/script&gt; common.js 123456789101112131415161718192021222324let data = []switch (this.$route.path) &#123; case '/order/inquiry': data = [ &#123; list: [ &#123;prop: 'name', label: '姓名', width: '100', show: true&#125;, &#123;prop: 'phone', label: '手机号', width: '150', show: true&#125; ], title: '全部', vision: '1' &#125;, &#123; list: [ &#123;prop: 'name', label: '姓名', width: '100', show: true&#125;, &#123;prop: 'status', label: '状态', width: '150', show: true&#125; ], title: '未处理', vision: '1' &#125; ] break; &#125;this.$emit('getShowContentListChange', data); 字段显示编辑组件order-setting.vue 使用插件 vuedraggable123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218&lt;template&gt; &lt;div class=&quot;order-setting&quot;&gt; &lt;div class=&quot;inner-order-setting&quot; v-if=&quot;$route.path.includes(&apos;order&apos;)&amp;&amp;!$route.path.includes(&apos;detail&apos;)&quot;&gt; &lt;span style=&quot;color: #999;font-size: 16px;&quot;&gt;显示字段&lt;/span&gt; &lt;i class=&quot;icon fa fa-cog&quot; style=&quot;color: #999;font-size: 20px&quot; @click=&quot;dialog=true&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;el-dialog size=&quot;tiny&quot; title=&quot;显示字段&quot; :visible.sync=&quot;dialog&quot;&gt; &lt;div class=&quot;dialog-order-setting&quot;&gt; &lt;el-row type=&quot;flex&quot; justify=&quot;space-around&quot;&gt; &lt;el-col :span=&quot;14&quot;&gt; &lt;div class=&quot;main-title&quot;&gt;基础信息&lt;/div&gt; &lt;hr class=&quot;long-one m-b-10&quot;&gt; &lt;el-checkbox :indeterminate=&quot;isIndeterminate&quot; v-model=&quot;checkAll&quot; @change=&quot;handleCheckAllChange&quot;&gt;全选 &lt;/el-checkbox&gt; &lt;div v-for=&quot;(outerItem,index) in showContentListArr&quot;&gt; &lt;hr class=&quot;one m-t-20 m-b-20&quot; v-if=&quot;index&gt;=1&quot;&gt; &lt;!--:label=&quot;`$&#123;item.index&#125;-$&#123;item.prop&#125;`&quot;--&gt; &lt;div&gt;&#123;&#123;outerItem.title&#125;&#125;&lt;/div&gt; &lt;el-checkbox @change=&quot;handleCheckedChange&quot; v-for=&quot;(item,index) in outerItem.list&quot; v-model=&quot;item.show&quot; :key=&quot;index&quot;&gt;&#123;&#123;item.label&#125;&#125; &lt;/el-checkbox&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;10&quot;&gt; &lt;span class=&quot;main-title&quot; style=&quot;color: red;&quot;&gt;编辑顺序&lt;/span&gt; &lt;hr class=&quot;long-one m-b-10&quot;&gt; &lt;el-radio-group v-model=&quot;active&quot; @change=&quot;activeChange&quot;&gt; &lt;el-radio :label=&quot;index&quot; v-for=&quot;(outerItem,index) in contentList&quot;&gt;&#123;&#123;outerItem.title&#125;&#125; &lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;draggable v-model=&quot;showContentList&quot; class=&quot;co-draggable&quot; :options=&quot;&#123;group:&apos;people&apos;&#125;&quot; @end=&quot;onSortStart($event,showContentList)&quot;&gt; &lt;transition-group&gt; &lt;div v-for=&quot;(item,index) in showContentList&quot; :key=&quot;index.toString()&quot; v-if=&quot;item.show&quot;&gt; &#123;&#123;item.label&#125;&#125; &lt;i @click=&quot;delTap(index)&quot; class=&quot;el-icon-close&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/transition-group&gt; &lt;/draggable&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;save&quot;&gt;保存&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;reset&quot;&gt;重置&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialog=false&quot;&gt;取消&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import draggable from &quot;vuedraggable&quot;; import &#123;mapGetters, mapMutations&#125; from &quot;vuex&quot;; export default &#123; components: &#123; draggable &#125;, props: &#123; contentList: &#123; type: [Array, Object], default() &#123; return []; &#125; &#125; &#125;, data() &#123; return &#123; dialog: false, showContentList: [], showContentListArr: [], checkAll: false, isIndeterminate: true, active: 0, &#125;; &#125;, methods: &#123; onSortStart(to, arr) &#123; this.showContentListArr[this.active].list = arr &#125;, save() &#123; const obj = Object.assign(&#123;&#125;, this.getShowContentList, &#123; [this.$route.path]: this.showContentListArr &#125;); this.dialog = false; this.setShowContentList(obj); // 刷新页面 this.$router.go(0) 最好是转跳到一个刷新组件 router.replace(&#123;path: &apos;/refresh&apos;, query: &#123;path&#125;&#125;) 在用组件里执行 router.replace(&#123;path: this.$route.query.path&#125;) &#125;, reset() &#123; this.clearShowContentList(); this.$router.go(0) &#125;, changeShowContent() &#123; if (this.$route.path.includes(&quot;order&quot;)) &#123; if (this.getShowContentList &amp;&amp; this.getShowContentList[this.$route.path]) &#123; // 当字段更新时 vision 需要修改和之前不一样的值 缓存的值才会重新赋值 if (this.getShowContentList[this.$route.path].length !== this.contentList.length) &#123; // 重新保存 console.log(&apos;重新保存&apos;) this.showContentListArr = this.contentList this.save() return false &#125; else &#123; for (let i = 0; i &lt; this.contentList.length; i++) &#123; if (this.contentList[i].list.length !== this.getShowContentList[this.$route.path][i].list.length|| this.contentList[i].vision!==this.getShowContentList[this.$route.path][i].vision) &#123; // 重新保存 console.log(&apos;重新保存&apos;) this.showContentListArr = this.contentList this.save() return false &#125; &#125; &#125; &#125; this.showContentListArr = this.getShowContentList &amp;&amp; this.getShowContentList[this.$route.path] ? this.getShowContentList[this.$route.path] : this.contentList this.showContentList = this.showContentListArr[this.active].list // console.log(this.showContentListArr) this.$emit(&quot;onSubmit&quot;, this.showContentListArr); &#125; &#125;, activeChange(active) &#123; this.showContentList = this.showContentListArr[active].list // console.log(this.showContentList) &#125;, handleCheckAllChange(val) &#123; for (let i = 0; i &lt; this.showContentListArr.length; i++) &#123; this.showContentListArr[i].list.forEach((item) =&gt; &#123; item.show = val &#125;) &#125; this.showContentList = this.showContentListArr[this.active].list this.isIndeterminate = false &#125;, handleCheckedChange(value) &#123; let isCheckAll = false let num = 0, total = 0 here: for (let i = 0; i &lt; this.showContentListArr.length; i++) &#123; for (let n = 0; n &lt; this.showContentListArr[i].list.length; n++) &#123; if (num &gt; 0 &amp;&amp; num &lt; total) &#123; break here; &#125; let item = this.showContentListArr[i].list[n] if (item.show) &#123; isCheckAll = true num++ &#125; total++ &#125; &#125; this.checkAll = isCheckAll; this.isIndeterminate = num &gt; 0 &amp;&amp; num &lt; total; &#125;, delTap(index) &#123; this.showContentList[index].show = false; &#125;, ...mapMutations(&#123; setShowContentList: &quot;setShowContentList&quot;, clearShowContentList: &quot;clearShowContentList&quot;, &#125;) &#125;, computed: &#123; ...mapGetters([&quot;getShowContentList&quot;]) &#125;, created() &#123; // setTimeout(() =&gt; &#123; this.changeShowContent(); this.handleCheckedChange() // &#125;, 0); &#125;, watch: &#123; contentList() &#123; this.changeShowContent(); &#125; &#125; &#125;;&lt;/script&gt;&lt;style&gt; .dialog-order-setting .el-checkbox &#123; margin-left: 0; margin-right: 30px; width: 100px; &#125; .dialog-order-setting .el-radio &#123; width: 100px; margin: 0 30px 10px 0; &#125; .co-draggable div &#123; padding: 6px 20px; cursor: all-scroll; border: 1px solid #e6e6e6; margin-bottom: 8px; border-radius: 4px; color: #363b42; &#125; .co-draggable div i &#123; float: right; color: #266298; font-size: 18px; vertical-align: middle; cursor: pointer; &#125;&lt;/style&gt; vuex getting.js123456const getters = &#123; getShowContentList: state =&gt; state.showContentList&#125;export default getters vuex mutations.js 使用插件 Lockr123456789101112131415import Lockr from 'lockr'const mutations = &#123; setShowContentList(state, showContentList) &#123; if (showContentList) &#123; state.showContentList = showContentList; Lockr.set('showContentList', showContentList) &#125; &#125;, clearShowContentList(state) &#123; state.showContentList = null; Lockr.rm('showContentList') &#125;,&#125;export default mutations vuex state.js123456import Lockr from 'lockr'const state = &#123; showContentList: Lockr.get('showContentList') || []&#125;export default state 使用的地方1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%&quot; stripe&gt; &lt;table-column :selection=&quot;true&quot; :list=&quot;showContentList[0].list&quot;&gt;&lt;/table-column&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;80&quot; fixed=&quot;right&quot;&gt; &lt;template scope=&quot;scope&quot;&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import tableColumn from &apos;common/table-column&apos;export default &#123; props: [&apos;showContentList&apos;], data()&#123; return &#123; tableData:[] &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"git的问题解决方法","slug":"git的问题解决方法","date":"2018-11-08T02:10:36.000Z","updated":"2020-07-08T02:45:38.089Z","comments":true,"path":"2018/11/08/git的问题解决方法/","link":"","permalink":"https://xiaojw.xyz/2018/11/08/git的问题解决方法/","excerpt":"","text":"正常提交文件12345git init (第一次需要)git add . (./表示所有文件 可指定文件夹/文件)git remote add origin git@github.com:xxxxgit.git (第一次需要)(ssh链接上传代码大小没有限制)git commit -m\"xxxx\"git push -u origin master /git push origin master 不正常提交文件git push 不上去,因为远程仓库有修改但本地没有拉取git stash 介绍123git stash /git stash save \"info\" // 将文件保存到暂存区git stash list // 查看暂存区列表git stash pop 将暂存区的内容弹出,并应用到当前分支对应的工作目录上. –rebase 介绍告诉Git把小红的提交移到同步了中央仓库修改后的master分支的顶部 解决112git pull --rebase origin master // 拉取远程仓库文件并把本地修改的文件置分支顶部git push origin master rebase操作过程是把本地提交一次一个地迁移到更新了的中央仓库master分支之上。 这意味着可能要解决在迁移某个提交时出现的合并冲突，而不是解决包含了所有提交的大型合并时所出现的冲突。 这样的方式让你尽可能保持每个提交的聚焦和项目历史的整洁。反过来，简化了哪里引入Bug的分析，如果有必要，回滚修改也可以做到对项目影响最小。 如果小红和小明的功能是不相关的，不大可能在rebase过程中有冲突。如果有，Git在合并有冲突的提交处暂停rebase过程，输出下面的信息并带上相关的指令： CONFLICT (content): Merge conflict in &lt;some-file&gt; git status 命令来查看哪里有问题接着小红编辑这些文件。修改完成后，用老套路暂存这些文件，并让git rebase完成剩下的事：12345git add &lt;some-file&gt; git rebase --continuegit rebase --abort // 回到你执行git pull --rebase命令前的样子：``` 解决21234git stash save \"info\" // 将本次修改文件提交到暂存区git pull --rebase origin master // 拉取远程仓库文件并把本地修改的文件置分支顶部git stash pop // 放出暂存区修改git push origin master // mastergit stash save “info” // 将本次修改文件提交到暂存区git checkout devgit stash pop // 放出暂存区修改 开发新功能1234git checkout -b marys-feature master// 相当于git checkout -b marys-featuregit merge master 这个命令检出一个基于master名为marys-feature的分支，Git的-b选项表示如果分支还不存在则新建分支。 这个新分支上，小红按老套路编辑、暂存和提交修改，按需要提交以实现功能： git push -u origin marys-feature 这条命令push marys-feature分支到中央仓库（origin），-u选项设置本地分支去跟踪远程对应的分支。 设置好跟踪的分支后，小红就可以使用git push命令省去指定推送分支的参数。 1234git checkout mastergit pullgit pull origin marys-featuregit push 合并分支12git merge --no-ff dev // 不使用fast-forward方式合并，保留分支的commit历史git merge --squash dev // 使用squash方式合并，把多次分支commit历史压缩为一次 之后要提交一次","categories":[{"name":"其他","slug":"其他","permalink":"https://xiaojw.xyz/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://xiaojw.xyz/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://xiaojw.xyz/categories/其他/"}]},{"title":"es6学习","slug":"es6学习","date":"2018-10-25T02:46:07.000Z","updated":"2020-07-08T02:45:38.089Z","comments":true,"path":"2018/10/25/es6学习/","link":"","permalink":"https://xiaojw.xyz/2018/10/25/es6学习/","excerpt":"","text":"es5缺陷与es6解决数组ES5 内建的forEach方法 缺陷：无法使用break 中断 ，也不能使用return 语句返回到外层函数 1. 遍历数组① for forEach123456789var arr = [1,2,3,4,5,6];arr.name = 'a';for (var index = 0; index &lt; arr.length; index++) &#123; console.log(arr[index]);&#125;arr.forEach(function (value) &#123; //ES5 内建的forEach方法 缺陷：无法使用break 中断 ，也不能使用return 语句返回到外层函数 console.log(value);&#125;);// 结果都是：1,2,3,4,5,6 ② 用 for-in ：作用于数组的 forfor -in 循环体除了遍历数组元素外,还会遍历自定义属性。比如数组有一个可枚举属性arr.a,循环将额外执行一次1234for (var index in arr) &#123; // 千万别这样做 console.log(arr[index]);&#125;// 结果：1,2,3,4,5,6，a for-in 是为普通对象设计的，赋值给index的值不是实际的数字1、2，而是字符串‘1’，‘2’123456var b = 0;for (var index in arr) &#123; b = b+ index; console.log(b)&#125;// 结果：00，001，0012，00123，001234，0012345，0012345name ③ 使用 for-of：避开了for-in 的所有缺陷，可以正确响应 break、return 语句\\1234for(var value of arr)&#123; console.log(value)&#125;// 结果：1,2,3,4,5,6 2.for-of 循环便利其他集合① 遍历Set12345678var words = 'a';var s = new Set();s.add(\"a\");s.add(1);for(var word of s)&#123; console.log(word);&#125;// 结果：a，1 ② 遍历Map123456789var map = new Map();map.set('a',1);map.set('b',2);map.set('c',3);map.set('d',4);for(var [key,value] of map)&#123; console.log(key+':'+value);&#125;// 结果：a：1，b：2，c：3，d：4 3. Iterator（遍历器）① 遍历器（Iterator）是一种接口规格，任何对象只要部署这个接口，就可以完成遍历操作。它的作用有两个，一是为各种数据结构，提供一个统一的、简便的接口，二是使得对象的属性能够按某种次序排列。 ② 遍历器的原理：遍历器提供了一个指针，指向当前对象的某个属性，使用next方法，就可以将指针移动到下一个属性。next方法返回一个包含value和done两个属性的对象。其中，value属性是当前遍历位置的值，done属性是一个布尔值，表示遍历是否结束。123456789101112131415//模拟遍历器原理function makeIterator(array)&#123; var nextIndex = 0; return &#123; next: function()&#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;&#125;var it = makeIterator(['a', 'b']);console.log(it.next());//&#123; value: 'a', done: false &#125;console.log(it.next());//&#123; value: 'b', done: false &#125;console.log(it.next());//&#123; value: undefined, done: true &#125; ③ Iterator接口返回的遍历器，原生具备next方法。 有三类数据结构原生具备Iterator接口：数组、类似数组的对象、Set和Map结构 能调用遍历器接口的 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])） Promise.all() Promise.race()123456var map = new Map();console.log(map[Symbol.iterator] === map.entries)//truevar arr = new Array();console.log(arr[Symbol.iterator] === arr.values)//truevar set = new Set();console.log(set[Symbol.iterator] === set.values)//true 其他数据结构（主要是对象）如果需要Iterator接口,都需要自己部署。123456789101112var students = &#123;&#125;students[Symbol.iterator] = function() &#123; let index = 1; return &#123; next() &#123; return &#123;done: index&gt;10, value: index++&#125; &#125; &#125;&#125;for(var i of students) &#123; console.log(i);&#125;// es6字符串的扩展includes(), startsWith(), endsWith()JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 第二参数数字 表示起始位置startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 第二参数数字 表示起始位置endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 第二参数数字 表示截止位置 12345let s = 'Hello world!';s.startsWith('world', 6); // trues.endsWith('Hello', 5); // trues.includes('Hello', 6); // false repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 123'x'.repeat(3); // \"xxx\"'hello'.repeat(2); // \"hellohello\"'na'.repeat(0); // \"\" 正小数,向下取整0- -1小数 为 -0 视为 0 参数字符串,NaN 会优先转为数字,转不了的话 为0 padStart()，padEnd()12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 如果用来补全的字符串与原字符串，两长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。 如果省略第二个参数，默认使用空格补全长度。12345'abc'.padStart(10, '0123456789')// '0123456abc''x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 另一个用途是提示字符串格式123456'1'.padStart(10, '0') // \"0000000001\"'12'.padStart(10, '0') // \"0000000012\"'123456'.padStart(10, '0') // \"0000123456\"'12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\"'09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\" matchAll()matchAll方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章 模板字符串 ${变量名}1234let a = 'xiaojw'let b =`我是$&#123;a&#125;哟!`console.log(`可以直接换行哟!`) 正则的扩展1.RegExp 构造函数1234567// 允许var regex = new RegExp('xyz', 'i');var regex = new RegExp(/xyz/i);// 等价于var regex = /xyz/i;// es5不允许 es6允许var regex = new RegExp(/xyz/, 'i'); 2.字符串的正则方法字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 3.u修饰符ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码 12345678910111213141516171819202122232425262728293031323334// 点字符var s = '𠮷';/^.$/.test(s); // false/^.$/u.test(s); // true// 如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。// 2.Unicode 字符表示法/\\u&#123;61&#125;/.test('a'); // false/\\u&#123;61&#125;/u.test('a'); // true/\\u&#123;20BB7&#125;/u.test('𠮷'); // true// 3.量词/a&#123;2&#125;/.test('aa'); // true/a&#123;2&#125;/u.test('aa'); // true/𠮷&#123;2&#125;/.test('𠮷𠮷'); // false/𠮷&#123;2&#125;/u.test('𠮷𠮷'); // true// 4.预定义模式/^\\S$/.test('𠮷'); // false/^\\S$/u.test('𠮷'); // true// 返回字符串长度的函数function codePointLength(text) &#123; var result = text.match(/[\\s\\S]/gu); return result ? result.length : 0;&#125;var s = '𠮷𠮷';s.length; // 4codePointLength(s) // 2// 5.i 修饰符/[a-z]/i.test('\\u212A'); // false/[a-z]/iu.test('\\u212A'); // true 4.RegExp.prototype.unicode 属性12345const r1 = /hello/;const r2 = /hello/u;r1.unicode; // falser2.unicode; // true 5.y 修饰符y修饰符与g修饰符类似,全局搜索但与g不同的地方是需要严格从上一次匹配的位置进行下一次匹配 且y修饰符号隐含了头部匹配的标志^。123456789var s = 'aaa_aa_a';var r1 = /a+/g;var r2 = /a+/y;r1.exec(s) // [\"aaa\"]r2.exec(s) // [\"aaa\"]r1.exec(s) // [\"aa\"] 剩余字符 _aa_ar2.exec(s) // null 剩余字符 _aa_a _匹配不上a 6.RegExp.prototype.sticky 属性与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。12var r = /hello\\d/y;r.sticky // true 7.RegExp.prototype.flagsES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 8.s 修饰符：dotAll 模式这被称为dotAll模式，即点（dot）代表一切字符。但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。 1.U+000A 换行符（\\n）2.U+000D 回车符（\\r）3.U+2028 行分隔符（line separator）4.U+2029 段分隔符（paragraph separator 所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。 9.后行断言(pattern) ： 匹配 pattern 并获取这一匹配，所获取的匹配可以从产生的 Matches 集合得到。(?:pattern) ：匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。(?!pattern) ：匹配 !pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。(?=pattern) ：正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (pattern)匹配pattern并捕获该匹配的子表达式.可以使用 $0…$9属性从结果”匹配”集合中检索捕获的匹配.若要匹配括号字符(),请使用””或者””或者””. (?:pattern)匹配pattern但不捕获该匹配的子表达式,即它是一个非捕获匹配,不存储供以后使用的匹配.这对于用”或”字符(|)组合模式部件的情况很有用. 例如,与”industry|industries”相比,”industr(?:y|ies)”是一个更加经济的表达式. let RegExp = /industr(y|ies)/ // 存储let RegExp1 = /industr(?:y|ies)/ // ?:不存储let result1 = ‘industry’.match(RegExp)let result2 = ‘industries’.match(RegExp) let result3 = ‘industry’.match(RegExp1)let result4 = ‘industries’.match(RegExp1) (?=pattern)执行正向预测先行搜索的子表达式,该表达式匹配处于匹配 pattern 的字符串的起始点的字符串.它是一个非捕获匹配,即不能捕获供以后使用的匹配. 例如,”Windows (?=95| 98| NT| 2000)”与”Windows 2000”中的”Windows”匹配,但不与”Windows 3.1”中的”Windows”匹配. 预测先行不占用字符,即发生匹配后,下一匹配的搜索紧随上一匹配之后,而不是在组成预测先行的字符后. (?!pattern)执行反向预测先行搜索的子表达式,该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串.它是一个非捕获匹配,即不能捕获供以后使用的匹配. 例如,”Windows (?!95| 98| NT| 2000)”与”Windows 3.1”中的”Windows”匹配,但不与”Windows 2000”中的”Windows”匹配. 预测先行不占用字符,即发生匹配后,下一匹配的搜索紧随上一匹配之后,而不是在组成预测先行的字符后. 作者：warmsmellofcolitas来源：CSDN原文：https://blog.csdn.net/warmsmellofcolitas/article/details/79403706版权声明：本文为博主原创文章，转载请附上博文链接！ 10.Unicode 属性类ES2018 引入了一种新的类的写法\\p{…}和\\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。12const regexGreekSymbol = /\\p&#123;Script=Greek&#125;/u;regexGreekSymbol.test('π') // true 上面代码中，\\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功 Unicode 属性类要指定属性名和属性值对于某些属性，可以只写属性名，或者只写属性值。123/\\p&#123;UnicodePropertyName=UnicodePropertyValue&#125;//\\p&#123;UnicodePropertyName&#125;//\\p&#123;UnicodePropertyValue&#125;/ \\P{…}是\\p{…}的反向匹配，即匹配不满足条件的字符。注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\\p和\\P会报错，ECMAScript 预留了这两个类。由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强12const regex = /^\\p&#123;Decimal_Number&#125;+$/u;regex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼'); // true 上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。 \\p{Number}甚至能匹配罗马数字。12345// 匹配所有数字const regex = /^\\p&#123;Number&#125;+$/u;regex.test('²³¹¼½¾'); // trueregex.test('㉛㉜㉝'); // trueregex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ'); // true 例子123456789101112131415// 匹配所有空格/\\p&#123;White_Space&#125;/// 匹配各种文字的所有字母，等同于 Unicode 版的 \\w/[\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]/// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W/[^\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]/// 匹配 Emoji/\\p&#123;Emoji_Modifier_Base&#125;\\p&#123;Emoji_Modifier&#125;?|\\p&#123;Emoji_Presentation&#125;|\\p&#123;Emoji&#125;\\uFE0F/gu// 匹配所有的箭头字符const regexArrows = /^\\p&#123;Block=Arrows&#125;+$/u;regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true 11.具名组匹配正则表达式使用圆括号进行组匹配。1const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/; 上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来123456const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。 ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。1234567const RE_DATE = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31// 数字序号（matchObj[1]）依然有效 没有找到匹配,属性值就是undefined 解构赋值和替换有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。123let &#123;groups: &#123;one, two&#125;&#125; = /^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u.exec('foo:bar');one // footwo // bar 字符串替换时，使用$&lt;组名&gt;引用具名组1234let re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u;'2015-01-02'.replace(re, '$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;')// '02/01/2015' 上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。 replace方法的第二个参数也可以是函数，该函数的参数序列如下。123456789101112'2015-01-02'.replace(re, ( matched, // 整个匹配结果 2015-01-02 capture1, // 第一个组匹配 2015 capture2, // 第二个组匹配 01 capture3, // 第三个组匹配 02 position, // 匹配开始的位置 0 S, // 原字符串 2015-01-02 groups // 具名组构成的一个对象 &#123;year, month, day&#125; ) =&gt; &#123; let &#123;day, month, year&#125; = groups; return `$&#123;day&#125;/$&#123;month&#125;/$&#123;year&#125;`;&#125;); 具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。 引用如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k&lt;组名&gt;的写法。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;$/;RE_TWICE.test('abc!abc'); // trueRE_TWICE.test('abc!ab'); // false 数字引用（\\1）依然有效123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\1$/;RE_TWICE.test('abc!abc'); // trueRE_TWICE.test('abc!ab'); // false 这两种引用语法还可以同时使用。123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;!\\1$/;RE_TWICE.test('abc!abc!abc') // trueRE_TWICE.test('abc!abc!ab') // false 12.String.prototype.matchAll如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。 123456789101112131415var regex = /t(e)(st(\\d?))/g;var string = 'test1test2test3';var matches = [];var match;while (match = regex.exec(string)) &#123; matches.push(match);&#125;matches// [// [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"],// [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"],// [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"]// ] 上面代码中，while循环取出每一轮的正则匹配，一共三轮。 目前有一个提案，增加了String.prototype.matchAll方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组1234567891011const string = 'test1test2test3';// g 修饰符加不加都可以const regex = /t(e)(st(\\d?))/g;for (const match of string.matchAll(regex)) &#123; console.log(match);&#125;// [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"]// [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"]// [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] 上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 遍历器转为数组是非常简单的，使用…运算符和Array.from方法就可以了。12345// 转为数组方法一[...string.matchAll(regex)]// 转为数组方法二Array.from(string.matchAll(regex)); 注:javascript中for…in和for…of的区别,以下括号中注的解释{for…of循环是ES6引入的新的语法。for…in遍历拿到的x是键（下标）。而for…of遍历拿到的x是值，但在对象中会提示不是一个迭代器报错。1234567891011121314151617let x;let a = ['A','B','C'];let b = &#123;name: '刘德华',age: '18'&#125;;console.log(a.length);for(x of a)&#123; console.log(x); //A,B,C&#125;for(x in a)&#123; console.log(x+':'+a[x]); //0:A,1:B,2:C&#125;/*for(x of b)&#123; console.log(x); //报错&#125;*/for(x in b)&#123; console.log(x); //name,age&#125; } 函数的扩展1.函数参数的默认值1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 与解构赋值默认值结合使用123456789function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125;) &#123; console.log(method);&#125;fetch('http://example.com', &#123;&#125;)// \"GET\"fetch('http://example.com')// 报错 两个写法的区别12345678910111213141516171819202122232425262728// 写法一function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 写法二function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x 和 y 都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x 有值，y 无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x 和 y 都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined]m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] 函数的 length 属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 作用域12345678910111213141516function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // ReferenceError: x is not definedvar x = 1;function foo(x = x) &#123; // ...&#125;foo() // R 上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。 12345678let foo = 'outer';function bar(func = () =&gt; foo) &#123; let foo = 'inner'; console.log(func());&#125;bar(); // outer 上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。 2.rest 参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 123456789101112function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10``` 3.尾调用优化什么是尾调用尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 123function f(x)&#123; return g(x);&#125; 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。 以下三种情况，都不属于尾调用。123456789101112131415// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125;// 情况三function f(x)&#123; g(x);&#125; 上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。1234function f(x)&#123; g(x); return undefined;&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可。123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 尾调用优化函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack） 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化” 1234567function addOne(a)&#123; var one = 1; function inner(b)&#123; return b + one; &#125; return inner(a);&#125; 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。123456function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。123456function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 非尾递归的 Fibonacci 数列实现如下。1234567891011function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;// f(3) =&gt; f(2)+ f(1) =&gt; f(1)+ f(0) + f(1) =&gt; 3Fibonacci(3) // 3Fibonacci(10) // 89Fibonacci(100) // 堆栈溢出Fibonacci(500) // 堆栈溢出 尾递归优化过的 Fibonacci 数列实现如下。1234567891011function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; // (序号,上一次结果,本次结果) return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;// f(3,1,1)= f(2,1,2)=f(1,2,3) = 3// f(4,1,1) = f(3,1,2)=f(2,2,3) =f(1,3,5) = 5Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。 严格模式ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。func.caller：返回调用当前函数的那个函数。尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。123456function restricted() &#123; 'use strict'; restricted.caller; // 报错 restricted.arguments; // 报错&#125;restricted(); 尾递归优化的实现尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 下面是一个正常的递归函数。12345678910function sum(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;sum(1, 100000)// Uncaught RangeError: Maximum call stack size exceeded(…) 上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。 蹦床函数（trampoline）可以将递归执行转为循环执行。123456function trampoline(f) &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125; 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。1234567function sum(x, y) &#123; if (y &gt; 0) &#123; return sum.bind(null, x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"将数组对象筛选处理合并成一个对象","slug":"将数组对象筛选处理合并成一个对象","date":"2018-10-24T02:59:25.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/10/24/将数组对象筛选处理合并成一个对象/","link":"","permalink":"https://xiaojw.xyz/2018/10/24/将数组对象筛选处理合并成一个对象/","excerpt":"","text":"问题有时候我们获取的数据是一个数组对象,但是提交数据的时候又要你把数组转为对象其中还要筛选没用的key 例:123456789101112[ &#123; name: '我的', phone: '122222', ttt: '迟到了吗' &#125;, &#123; name: '我的', phone: '122222', ttt: '迟到了吗' &#125;, &#123; name: '我的', phone: '122222', ttt: '迟到了吗' &#125;]处理为const obj =&#123; name1: '我的', phone1: '122222', name2: '我的', phone2: '122222', name3: '我的', phone3: '122222' &#125; 12345678910111213141516// filter 为筛选 项(即数组中的符合项)// map 为 处理每一项中 所需的内容(key)const arr = [ &#123; name: '我的', phone: '122222', ttt: '迟到了吗' &#125;, &#123; name: '我的', phone: '122222', ttt: '迟到了吗' &#125;, &#123; name: '我的', phone: '122222', ttt: '迟到了吗' &#125;]const arr1 = arr.map((item, index) =&gt; &#123; let obj = &#123;&#125; obj[`name$&#123;index + 1&#125;`] = item.name obj[`phone$&#123;index + 1&#125;`] = item.phone return obj&#125;)// console.log(arr1)const obj = Object.assign(&#123;&#125;,...arr1)console.log(obj)","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"解决vue不能使用锚标记时的方法","slug":"解决vue不能使用锚标记时的方法","date":"2018-10-23T09:48:24.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/10/23/解决vue不能使用锚标记时的方法/","link":"","permalink":"https://xiaojw.xyz/2018/10/23/解决vue不能使用锚标记时的方法/","excerpt":"","text":"普通的锚标记转跳123&lt;a href=\"#q\"&gt;转跳&lt;/a&gt;&lt;a name=\"q\"&gt;转跳到这&lt;/a&gt; 以上方法不能转跳到对应位置的话,用这种123456789&lt;div @click=\"returnTo('xxx')\"&gt;转跳&lt;/div&gt;&lt;div id=\"xxx\"&gt;转跳到这&lt;/h3&gt;// methods 里returnTo(name) &#123; document.querySelector(`#$&#123;name&#125;`).scrollIntoView(true)&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"七牛云上传文件demo","slug":"七牛云上传文件demo","date":"2018-09-20T08:46:46.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/09/20/七牛云上传文件demo/","link":"","permalink":"https://xiaojw.xyz/2018/09/20/七牛云上传文件demo/","excerpt":"","text":"七牛云上传文件demo这是我前几天写的 因为之前的上传会出现文件的MimeType不对 还有一些错误 所以现在写的有些复杂 (删除七牛云上与本地相同的文件-这一步其实可以没有,但我担心有重复文件导致不上传,所以还是删除吧) 读取本地保存的上一次上传记录删除七牛云上一次上传记录的文件删除七牛云上与本地相同的文件上传文件并指定文件的MimeType记录上传的文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265const fs = require('fs')const qiniu = require('qiniu')// 授权秘钥const accessKey = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'const secretKey = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'// 存储空间名称const bucket = 'xiaojw'// 要上传的资源目录const staticPath = '../xxx_trunk/xiaojw'// 上传后的文件前缀const prefix = 'xiaojw'const cdnPrefix = 'https://cdn.xxxxxxxx.com/'// 创建鉴权对象const mac = new qiniu.auth.digest.Mac(accessKey, secretKey)// 创建并修改配置对象(Zone_z0=华东 Zone_z1=华北 Zone_z2=华南 Zone_na0=北美)const config = new qiniu.conf.Config()config.zone = qiniu.zone.Zone_z2// 创建额外内容对象const putExtra = new qiniu.form_up.PutExtra()// 创建表单上传对象const formUploader = new qiniu.form_up.FormUploader(config)// 文件批量操作对象const bucketManager = new qiniu.rs.BucketManager(mac, config);const Mime = ['application/javascript', 'text/css', 'image/jpeg', 'image/png', 'text/html']// 文件上传方法function uploadFile(localFile) &#123; // 配置上传到七牛云的完整路径 const key = localFile.replace(staticPath, prefix) // console.log('准备上传文件: ' + key) const options = &#123; scope: bucket + \":\" + key &#125; const putPolicy = new qiniu.rs.PutPolicy(options) // 生成上传凭证 const uploadToken = putPolicy.uploadToken(mac) // 上传文件 let index = key.lastIndexOf('.') if (index) &#123; let suffix = key.slice(index + 1) switch (suffix) &#123; case 'js': putExtra.mimeType = Mime[0] break case 'css': putExtra.mimeType = Mime[1] break case 'jpeg': case 'jpg': putExtra.mimeType = Mime[2] break case 'png': putExtra.mimeType = Mime[3] break case 'html': putExtra.mimeType = Mime[4] break default: console.log('未设置的上传类型') &#125; &#125; // console.log(key) if (!key) &#123; console.log('路径出问题') return &#125; formUploader.putFile(uploadToken, key, localFile, putExtra, function (respErr, respBody, respInfo) &#123; if (respErr) &#123; console.log('上传出错:\\t' + cdnPrefix + key) console.log(respErr) // throw respErr return &#125; // console.log('已上传: ', respBody.key) appendFile(`$&#123;respBody.key&#125;\\n`) // appendFile(`$&#123;key&#125;\\n`) &#125;)&#125;// 目录上传方法async function uploadDirectory(dirPath) &#123; fs.readdir(dirPath, function (err, files) &#123; if (err) throw err // 遍历目录下的内容 files.forEach(item =&gt; &#123; let path = `$&#123;dirPath&#125;/$&#123;item&#125;` fs.stat(path, function (err, stats) &#123; if (err) throw err // 是目录就接着遍历 否则上传 if (stats.isDirectory()) uploadDirectory(path) else &#123; const key = path.replace(staticPath, prefix) // 删除七牛云上与本地相同的文件 // console.log(key) // console.log(path) deleteSigleF(key).then(()=&gt;&#123; uploadFile(path) &#125;).catch(()=&gt;&#123; uploadFile(path) &#125;) &#125; &#125;) &#125;) &#125;)&#125;// 批量删除文件方法function deleteFile(deleteOperations) &#123; return new Promise((resolve, reject) =&gt; &#123; //每个operations的数量不可以超过1000个，如果总数量超过1000，需要分批发送 if (!deleteOperations) &#123; console.log('删除的文件数组不存在') return false &#125; bucketManager.batch(deleteOperations, function (err, respBody, respInfo) &#123; if (err) &#123; console.log(\"文件批量删除出错\"); console.log(err); // throw err; &#125; else &#123; // 200 is success, 298 is part success if (parseInt(respInfo.statusCode / 100) == 2) &#123; respBody.forEach(function (item) &#123; if (item.code == 200) &#123; // console.log(item.code + \"\\tsuccess\") console.log(\"删除成功\") // console.log(respBody) resolve(\"删除成功\") &#125; else &#123; // console.log(item.code + \"\\t\" + item.data.error) console.log(\"删除失败\" + item.data.error) reject(\"删除失败\" + item.data.error) &#125; &#125;); &#125; else &#123; console.log(respInfo.deleteusCode); console.log(respBody); console.log('错误101--------------------'); reject(respBody) &#125; &#125; &#125;) &#125;)&#125;// 删除单个文件function deleteSigleF(path) &#123; return new Promise((resolve, reject) =&gt; &#123; bucketManager.delete(bucket, path, function (err, respBody, respInfo) &#123; if (err) &#123; // console.log(\"删除失败\" + err + \"\\t 路径:\" + path); console.log(\"删除失败\" + err); reject() //throw err; &#125; else &#123; // console.log(respInfo.statusCode, respBody); console.log(respBody, path) resolve() &#125; &#125;) &#125;)&#125;async function readFile(returnType = false) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile('./file.txt', &#123;flag: 'r+', encoding: 'utf-8'&#125;, function (err, data) &#123; if (err) &#123; reject(err) &#125; else &#123; let dataArr = data.split('\\n') if (returnType) &#123; resolve(dataArr) return &#125; console.log('\\n上一次上传文件--------------------\\n') console.log(dataArr) let deleteOperations = [] dataArr.forEach((item) =&gt; &#123; if (item) &#123; deleteOperations.push(qiniu.rs.deleteOp(bucket, item)) &#125; &#125;) resolve(deleteOperations) &#125; &#125;) &#125;)&#125;function writeFile(content) &#123; fs.writeFile('./file.txt', content, &#123;flag: 'w', encoding: 'utf-8', mode: '0666'&#125;, function (err) &#123; if (err) &#123; console.log(\"文件写入失败\") &#125; else &#123; console.log(\"删除服务器上相同文件,记录文件\" + (content ? '变为' + content + '\\n' : '清空,---------------\\n')); &#125; &#125;)&#125;function appendFile(content) &#123; fs.writeFile('./file.txt', content, &#123;flag: 'a', encoding: 'utf-8', mode: '0666'&#125;, function (err) &#123; if (err) &#123; console.log(\"已上传但未记录:\\t\" + cdnPrefix + content.replace('\\n', '')) &#125; else &#123; console.log(\"已上传并记录:\\t\" + cdnPrefix + content.replace('\\n', '')); &#125; &#125;)&#125;function uploadHome() &#123; // 清空文件内容 writeFile('') fs.exists(staticPath, function (exists) &#123; if (!exists) &#123; console.log('目录不存在！') &#125; else &#123; console.log('\\n开始上传...') uploadDirectory(staticPath) &#125; &#125;)&#125;// 读取本地保存的上一次上传记录// 删除七牛云上一次上传记录的文件// 删除七牛云上与本地相同的文件// 上传文件并指定文件的MimeType// 记录上传的文件async function exec() &#123; // 读取 let deleteOperations = await readFile() // console.log(deleteOperations) // 删除七牛云上一次上传记录的文件 console.log('\\n删除上一次上传文件---------------\\n') if (deleteOperations.length) &#123; // let deleteOP = await deleteFile(deleteOperations) // console.log(deleteOP) deleteFile(deleteOperations).then((res) =&gt; &#123; // console.log(res) uploadHome() &#125;).catch((err) =&gt; &#123; // console.log(err) uploadHome() &#125;) &#125; else &#123; uploadHome() &#125;&#125;exec() 运行node qiniuUpload.js 修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235const fs = require('fs');const qiniu = require('qiniu');// 授权秘钥const accessKey = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';const secretKey = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';// 存储空间名称const bucket = \"xiaojw\";const ENV = process.argv[2] === 'prod' ? 'prod' : (process.argv[2] === 'test' ? 'test' : 'dev');const date = new Date();const appendPath = `$&#123;date.getFullYear()&#125;/$&#123;date.getMonth() + 1&#125;/$&#123;date.getDate()&#125;`;// 要上传的资源目录const staticPath = `./dist`;// 上传后的文件前缀const prefix = `admin/$&#123;ENV&#125;/$&#123;appendPath&#125;`;// cdn域名const cdnPrefix = 'https://cdn.xxxxx.com/';// 创建鉴权对象const mac = new qiniu.auth.digest.Mac(accessKey, secretKey);// 创建并修改配置对象(Zone_z0=华东 Zone_z1=华北 Zone_z2=华南 Zone_na0=北美)const config = new qiniu.conf.Config();config.zone = qiniu.zone.Zone_z2;// 创建额外内容对象const putExtra = new qiniu.form_up.PutExtra();// 创建表单上传对象const formUploader = new qiniu.form_up.FormUploader(config);// 文件批量操作对象const bucketManager = new qiniu.rs.BucketManager(mac, config);const Mime = &#123; js: 'application/javascript', css: 'text/css', jpeg: 'image/jpeg', jpg: 'image/jpeg', png: 'image/png', html: 'text/html', gz: 'application/x-gzip', gif: 'image/gif'&#125;;const MineKeyArr = Object.keys(Mime);// 文件上传方法function uploadFile(localFile) &#123; // 配置上传到七牛云的完整路径 const key = localFile.replace(staticPath, prefix); const options = &#123; scope: bucket + \":\" + key &#125;; const putPolicy = new qiniu.rs.PutPolicy(options); // 生成上传凭证 const uploadToken = putPolicy.uploadToken(mac); // 上传文件 let index = key.lastIndexOf('.'); if (index) &#123; let suffix = key.slice(index + 1); if (MineKeyArr.includes(suffix)) &#123; putExtra.mimeType = Mime[suffix]; &#125; else &#123; console.log('未设置的上传类型'); &#125; &#125; if (!key) &#123; console.log('路径出问题'); return; &#125; formUploader.putFile(uploadToken, key, localFile, putExtra, function (respErr, respBody, respInfo) &#123; if (respErr) &#123; console.log('上传出错:\\t' + cdnPrefix + key); console.log(respErr); return; &#125; baseFile(`$&#123;respBody.key&#125;\\n`,true); &#125;)&#125;// 目录上传方法async function uploadDirectory(dirPath) &#123; fs.readdir(dirPath, function (err, files) &#123; if (err) throw err; // 遍历目录下的内容 files.forEach(item =&gt; &#123; let path = `$&#123;dirPath&#125;/$&#123;item&#125;`; fs.stat(path, function (err, stats) &#123; if (err) throw err; // 是目录就接着遍历 否则上传 if (stats.isDirectory()) uploadDirectory(path); else &#123; const key = path.replace(staticPath, prefix); // 删除相同环境下七牛云上与本地相同的文件 if (key.includes(ENV)) &#123; deleteSigleF(key).then(() =&gt; &#123; uploadFile(path); &#125;).catch(() =&gt; &#123; uploadFile(path); &#125;) &#125; &#125; &#125;); &#125;) &#125;);&#125;// 批量删除文件方法function deleteFile(deleteOperations) &#123; return new Promise((resolve, reject) =&gt; &#123; //每个operations的数量不可以超过1000个，如果总数量超过1000，需要分批发送 if (!deleteOperations) &#123; console.log('删除的文件数组不存在'); return false; &#125; bucketManager.batch(deleteOperations, function (err, respBody, respInfo) &#123; if (err) &#123; console.log(\"文件批量删除出错\"); console.log(err); &#125; else &#123; // 200 is success, 298 is part success if (parseInt(respInfo.statusCode / 100) === 2) &#123; respBody.forEach(function (item) &#123; if (item.code === 200) &#123; console.log(\"删除成功\"); // console.log(respBody); resolve(\"删除成功\"); &#125; else &#123; console.log(\"删除失败\" + item.data.error); reject(\"删除失败\" + item.data.error); &#125; &#125;); &#125; else &#123; console.log(respInfo.deleteusCode); console.log(respBody); console.log('错误101--------------------'); reject(respBody); &#125; &#125; &#125;); &#125;);&#125;// 删除单个文件function deleteSigleF(path) &#123; return new Promise((resolve, reject) =&gt; &#123; bucketManager.delete(bucket, path, function (err, respBody, respInfo) &#123; if (err) &#123; // console.log(\"删除失败\" + err + \"\\t 路径:\" + path); console.log(\"删除失败\" + err); reject(); &#125; else &#123; console.log(respBody, path); resolve(); &#125; &#125;); &#125;);&#125;async function readFile(returnType = false) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(`./file-$&#123;ENV&#125;.txt`, &#123;flag: 'r+', encoding: 'utf-8'&#125;, function (err, data) &#123; if (err) &#123; reject(err); &#125; else &#123; let dataArr = data.split('\\n'); if (returnType) &#123; resolve(dataArr); return; &#125; console.log('\\n上一次上传文件--------------------\\n'); console.log(dataArr); let deleteOperations = []; dataArr.forEach((item) =&gt; &#123; if (item) &#123; deleteOperations.push(qiniu.rs.deleteOp(bucket, item)); &#125; &#125;); resolve(deleteOperations); &#125; &#125;); &#125;);&#125;function baseFile(content, isAppend) &#123; fs.writeFile(`./file-$&#123;ENV&#125;.txt`, content, &#123;flag: isAppend ? 'a' : 'w', encoding: 'utf-8', mode: '0666'&#125;, function (err) &#123; let str = \"\"; if (isAppend) &#123; str = (err ? \"已上传但未记录:\\t\" : \"已上传并记录:\\t\") + cdnPrefix + content.replace('\\n', ''); &#125; else &#123; str = err ? \"文件写入失败\" : (\"删除服务器上相同文件,记录文件\" + (content ? '变为' + content + '\\n' : '清空---------------\\n')); &#125; console.log(str); &#125;);&#125;function uploadHome() &#123; // 清空文件内容 baseFile(''); fs.exists(staticPath, function (exists) &#123; if (!exists) &#123; console.log('目录不存在！'); &#125; else &#123; uploadDirectory(staticPath); console.log('\\n开始上传...'); &#125; &#125;)&#125;// 1.读取本地保存的上一次上传记录// 2.删除七牛云上一次上传记录的文件// 3.删除七牛云上与本地相同的文件// 4.上传文件并指定文件的MimeType// 5.记录上传的文件async function exec() &#123; // let deleteOperations = await readFile(); // console.log('\\n删除上一次上传文件---------------\\n'); // if (deleteOperations.length) &#123; // // let deleteOP = await deleteFile(deleteOperations); // deleteFile(deleteOperations).then((res) =&gt; &#123; // uploadHome(); // &#125;).catch((err) =&gt; &#123; // uploadHome(); // &#125;) // &#125; else &#123; // uploadHome(); // &#125; uploadHome();&#125;exec(); 运行 node qiniuUpload.js devnode qiniuUpload.js prodnode qiniuUpload.js test","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"iOS上输入框光标错位问题","slug":"iOS上输入框光标错位问题","date":"2018-09-20T08:26:11.000Z","updated":"2020-07-08T02:45:38.089Z","comments":true,"path":"2018/09/20/iOS上输入框光标错位问题/","link":"","permalink":"https://xiaojw.xyz/2018/09/20/iOS上输入框光标错位问题/","excerpt":"","text":"iOS上,fixed 元素内的输入元素,获取焦点时的光标错位问题 转载来源如果一个输入元素（input, textarea …）的父容器设置了 position: fixed，当这个元素获取焦点时，滚动网页光标便错位 遗憾的是，截至目前，iOS 11.x 上也有这个问题。 解决方法一:不使用fixed 布局如果一定要使用请看下一种方法 解决方法二:动态改变布局方式当元素获取焦点时，改变父容器的定位方式：fixed &gt; absolute123456789101112for (let evt of ['focus', 'blur']) &#123; const isFocus = evt === 'focus' const fn = isFocus ? 'add' : 'remove' inputDOMNode.addEventListener(evt, () =&gt; &#123; parentDOMNode.classList[fn]('input-focus') htmlDOMNode.classList[fn]('no-scroll') bodyDOMNode.classList[fn]('no-scroll') isFocus &amp;&amp; setScrollTop(0) &#125;)&#125; 123456789.input-focus &#123; position: absolute; ...&#125;.no-scroll &#123; height: 100%; overflow: hidden;&#125; 监听了输入元素 focus 和 blur 事件，为父元素添加或移除某些样式。 当 position: absolute 时，输入框的定位方式需要手动设置（这里采取了顶部对齐）；.no-scroll 是为了禁止 body 的滚动，保证输入框可见。 但是这个方案在部分 Android 设备上，当键盘收起时并不会触发输入元素的 blur 事件，往往还需要用户主动点击页面的其他区域，算是一点小遗憾吧。 所以监听改变前先判断手机是ios还是android android就不监听 解决方法三:直接给html, body元素设置样式(推荐)123456html,body &#123; -webkit-overflow-scroll: touch !important; overflow: auto !important; height: 100% !important;&#125; -webkit-overflow-scrolling控制元素在移动设备上是否使用滚动回弹效果。12-webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */overflow: auto; /* 由浏览器定夺，如果内容被修剪，就会显示滚动条 */ 当输入元素获取焦点时，键盘弹起，输入元素被顶到了键盘的上方，此时用户的手指会从触摸屏上移开，输入元素会保持一段时间的滚动，从而光标的位置可以被正确计算。 !important 在这里是为了防止这些属性会因为浏览器优先级过高而发生变化。有点小遗憾的是，!important 侵入性有些高。 解决方法四:IOS系统修复慢慢等,说不定下一次更新也没有修复","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"vue的url去掉难看的井号并解决相关问题","slug":"去掉vue的url中难看的井号并解决相关问题","date":"2018-09-19T08:26:10.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/09/19/去掉vue的url中难看的井号并解决相关问题/","link":"","permalink":"https://xiaojw.xyz/2018/09/19/去掉vue的url中难看的井号并解决相关问题/","excerpt":"","text":"一、首先在路由文件配置history模式12345678910// 增加 mode: 'history'export default new Router(&#123; mode: 'history', routes: [ &#123; path: '/', redirect: '/login' &#125; ]&#125;) 二、使用history后一切都正常,唯有刷新浏览器的时候就不会加载了因为刷新后 服务器上没有对应的静态页对应 解决 将服务器上路径设置对应的定向 后端配置例子Apache12345678&lt;IfModule mod_rewrite.c&gt; RewriteEngine On RewriteBase / RewriteRule ^index\\.html$ - [L] RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteRule . /index.html [L]&lt;/IfModule&gt; 除了 mod_rewrite，你也可以使用 FallbackResource nginx123location / &#123; try_files $uri $uri/ /index.html;&#125; 原生 Node.js12345678910111213141516171819const http = require('http')const fs = require('fs')const httpPort = 80http.createServer((req, res) =&gt; &#123; fs.readFile('index.htm', 'utf-8', (err, content) =&gt; &#123; if (err) &#123; console.log('We cannot open \"index.htm\" file.') &#125; res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;) res.end(content) &#125;)&#125;).listen(httpPort, () =&gt; &#123; console.log('Server listening on: http://localhost:%s', httpPort)&#125;) 基于 Node.js 的 Express对于 Node.js/Express，请考虑使用connect-history-api-fallback 中间件 12345678910111213const express = require('express');const history = require('connect-history-api-fallback');const app = express();app.use(history( &#123; htmlAcceptHeaders: ['text/html', 'application/xhtml+xml'] &#125;));app.use(express.static('dist'));const server = app.listen(3002, function () &#123; const port = server.address().port; console.log(`listening at http://localhost:$&#123;port&#125;`);&#125;); Internet Information Services (IIS)1.安装 IIS UrlRewrite2.在你的网站根目录中创建一个web.config文件，内容如下：1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;system.webServer&gt; &lt;rewrite&gt; &lt;rules&gt; &lt;rule name=\"Handle History Mode and custom 404/500\" stopProcessing=\"true\"&gt; &lt;match url=\"(.*)\" /&gt; &lt;conditions logicalGrouping=\"MatchAll\"&gt; &lt;add input=\"&#123;REQUEST_FILENAME&#125;\" matchType=\"IsFile\" negate=\"true\" /&gt; &lt;add input=\"&#123;REQUEST_FILENAME&#125;\" matchType=\"IsDirectory\" negate=\"true\" /&gt; &lt;/conditions&gt; &lt;action type=\"Rewrite\" url=\"/\" /&gt; &lt;/rule&gt; &lt;/rules&gt; &lt;/rewrite&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; Caddy1234rewrite &#123; regexp .* to &#123;path&#125; /&#125; Firebase 主机在你的firebase.json中加入：1234567891011&#123; \"hosting\": &#123; \"public\": \"dist\", \"rewrites\": [ &#123; \"source\": \"**\", \"destination\": \"/index.html\" &#125; ] &#125;&#125; 警告因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。123456const router = new VueRouter(&#123; mode: 'history', routes: [ &#123; path: '*', component: NotFoundComponent &#125; ]&#125;) 或者，如果你使用 Node.js 服务器，你可以用服务端路由匹配到来的 URL，并在没有匹配到路由的时候返回 404，以实现回退。更多详情请查阅 Vue 服务端渲染文档。","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"关于vue中修改UI库样式的坑","slug":"关于vue中修改UI库样式的坑","date":"2018-09-19T03:57:01.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/09/19/关于vue中修改UI库样式的坑/","link":"","permalink":"https://xiaojw.xyz/2018/09/19/关于vue中修改UI库样式的坑/","excerpt":"","text":"一、怎么修改样式都不生效，在浏览器上改就能生效原因一: style标签加了scoped属性&lt;style scoped&gt;,去掉即可12&lt;style&gt;&lt;/style&gt; 原因二: 那就是选择器没选中咯,检查检查二、修改样式后影响了其他组件的样式原因:直接在UI组件上加的样式解决:在外层再套一层标签 加上限制,便不会影响全局了例:123456789101112131415---------------------template---------------------&lt;div class=\"elinput\"&gt; &lt;el-input v-model=\"form.VerificationCode\" placeholder=\"输入验证码\" auto-complete=\"ture\"&gt;&lt;/el-input&gt;&lt;/div&gt;---------------------style---------------------.elinput .el-input&#123;// 写样式&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"淘宝主图换图技术","slug":"淘宝主图换图技术","date":"2018-09-12T10:18:39.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/09/12/淘宝主图换图技术/","link":"","permalink":"https://xiaojw.xyz/2018/09/12/淘宝主图换图技术/","excerpt":"","text":"淘宝主图换图技术(包更新),认准QQ:1058330410简单原理抓包修改抓包的提交主图的url,改为访问服务器服务器根据,是否为pc,mobile,显示不同的图片提交修改内容到对应接口 一、发布商品并把在淘宝图片空间选择的主图链接复制到这（这图就是pc端显示的）pc：https://img.alicdn.com/imgextra/i3/4011718250/TB27z3RtEOWBKNjSZKzXXXfWFXa_!!4011718250.jpg 同样在淘宝图片空间选择一张图片（移动端要显示的图片）复制链接，到这 mobile：https://img.alicdn.com/imgextra/i4/4011718250/TB25IdCpWAoBKNjSZSyXXaHAVXa_!!4011718250.jpg 二、进入服务器地址: http://web.xiaojw.xyz/taobao_DI ,登录账号密码(一个店铺可多个账号)(需要账号联系我)，选择创建链接，填写PC端图片名称（既pc端的图片链接对应的部分）：TB27z3RtEOWBKNjSZKzXXXfWFXa_!!4011718250.jpgPC端的图片：https://img.alicdn.com/imgextra/i3/4011718250/TB27z3RtEOWBKNjSZKzXXXfWFXa_!!4011718250.jpg移动端要显示的图片： https://img.alicdn.com/imgextra/i4/4011718250/TB25IdCpWAoBKNjSZSyXXaHAVXa_!!4011718250.jpg 点击立即增加按钮，增加成功后点击复制代码：复制到这例http://119.29.143.126/alicdn.com/4011718250/TB27z3RtEOWBKNjSZKzXXXfWFXa_!!4011718250.jpg 三、下载并打开fiddler软件（百度就能搜索到）（安装后在开始那里可以找到软件）配置fiddler： 点击选项Tools-options-Https 勾选Decrypt Https traffic 弹出时全部点确认就行 再勾选 Ignore server certificate errors(unsafe)接着进去淘宝商家出售中宝贝-&gt;编辑宝贝-&gt;清空fiddler-&gt;再点击发布宝贝,回到fiddler找到绿色箭头upload.taobao.com这行 右键选择Replay-reissue and Edit 右边选项卡 选择webForm 将Body 里的dataBody 的内容剪切出来 {“stuffStatus”:5,”title”:”2018测试双图”,”multiMedia”:{“image”:[{“url”:”https://img.alicdn.com/imgextra/i3/4011718250/TB27z3RtEOWBKNjSZKzXXXfWFXa_!!4011718250.jpg&quot;,&quot;major&quot;:true,&quot;position&quot;:0}],&quot;imageVideo&quot;:{&quot;interactiveId&quot;:&quot;&quot;,&quot;videoId&quot;:&quot;&quot;}},&quot;price&quot;:&quot;11&quot;,&quot;quantity&quot;:1000,&quot;purchaseLocation&quot;:{&quot;isGlobalStock&quot;:&quot;false&quot;},&quot;descForPC&quot;:&quot; 13213“,”descForMobile”:[{“type”:”text”,”value”:” 13213”}],”deliverWay”:[1],”deliverTemplate”:15440272050,”afterSale”:{“sellPromise”:[1],”custom”:[3]},”subStockType”:1,”startTime”:{“startType”:0},”catId”:127666020,”itemId”:577320607928} 将url:后面的链接替换为重网站上复制的链接例如:{“stuffStatus”:5,”title”:”2018.9主图双图”,”multiMedia”:{“image”:[{“url”:”http://119.29.143.126/alicdn.com/4011718250/TB27z3RtEOWBKNjSZKzXXXfWFXa_!!4011718250.jpg&quot;,&quot;major&quot;:true,&quot;position&quot;:0}],&quot;imageVideo&quot;:{&quot;interactiveId&quot;:&quot;&quot;,&quot;videoId&quot;:&quot;&quot;}},&quot;price&quot;:&quot;11&quot;,&quot;quantity&quot;:1000,&quot;purchaseLocation&quot;:{&quot;isGlobalStock&quot;:&quot;false&quot;},&quot;descForPC&quot;:&quot; 13213“,”descForMobile”:[{“type”:”text”,”value”:” 13213”}],”deliverWay”:[1],”deliverTemplate”:15440272050,”afterSale”:{“sellPromise”:[1],”custom”:[3]},”subStockType”:1,”startTime”:{“startType”:0},”catId”:127666020,”itemId”:577320607928} 改完后再完整的复制会原来的位置点击下面的run to complete 返回宝贝页面 的淘宝购买页 (宝贝详情最右边有个手机购买) 鼠标移过去 用手机扫码","categories":[{"name":"其他","slug":"其他","permalink":"https://xiaojw.xyz/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://xiaojw.xyz/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://xiaojw.xyz/categories/其他/"}]},{"title":"关于列表水平展示的方法","slug":"关于列表水平展示的方法","date":"2018-09-07T10:38:22.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/09/07/关于列表水平展示的方法/","link":"","permalink":"https://xiaojw.xyz/2018/09/07/关于列表水平展示的方法/","excerpt":"","text":"一、使用float:left; 或 float:right这个方法水平排列起来简单 只需1float:left; 但是会引起一些不必要的问题: 父级盒子没有float部分的高度,因为float脱离了标准文档流解决办法可以设置父级的高,清理浮动,清理浮动的方式有很多,推荐使用伪类清理法123456789101112&lt;div class ='clearfix'&gt;&lt;/div&gt;.clearfix::after &#123; content: \".\"; clear: both; display: block; overflow: hidden; font-size: 0; height: 0;&#125;// 为兼容IE6,IE7，因为ie6,ie7不能用after伪类。加上下面代码.clearfix&#123;zoom:1&#125; 二、设置元素为行内块元素在需要水平排列的地方1display: inline-block; 问题 两个块中会有间隙例12&lt;div&gt;一&lt;/div&gt;&lt;div&gt;二&lt;/div&gt; 解决一.去掉两个中的间隙1&lt;div&gt;一&lt;/div&gt;&lt;div&gt;二&lt;/div&gt; 解决二设置父元素font-size为0或者line-height为0,子元素再对应设置font-size.line-height123456789101112131415&lt;div class=\"outer\"&gt; &lt;div&gt;一&lt;/div&gt; &lt;div&gt;二&lt;/div&gt;&lt;/div&gt;---------style---------.outer&#123; font-size:0; line-height:0;&#125;.outer div&#123; font-size:18px; line-height:30px;&#125; 三、使用flex布局在需要水平排列的父布局中 12display: flex;// flex-wrap: wrap; /*超出宽度强制换行*/ 在子布局中 12flex: 1;// 更多参数选择请自行百度 flex","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"数组与字符串的那些相似方法","slug":"数组与字符串的那些相似方法","date":"2018-09-04T08:22:16.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/09/04/数组与字符串的那些相似方法/","link":"","permalink":"https://xiaojw.xyz/2018/09/04/数组与字符串的那些相似方法/","excerpt":"","text":"一、字符串方法1、slice() 提取字符串的片断，并在新的字符串中返回被提取的部分。12345678stringObject.slice(start,end) // start 起始下标 负数时,从尾部开始算起位置: -1 最后,-2 倒数二// end 结束下标 省略时,表示到最后,负数时,同上// e.g.var str=\"Hello happy world!\"console.log(str.slice(6))// happy world! 2、substr() 从起始索引号提取字符串中指定数目的字符。(不建议使用 ECMAscript没有对该方法进行标准化)12345678stringObject.substr(start,length)// start 必须 起始下标,num 负数时,从尾部开始算起位置: -1 最后,-2 倒数二// length 可选 长度,num 省略时,表示到最后// e.g.var str=\"Hello world!\"console.log(str.substr(3))// lo world! 3、substring() 提取字符串中两个指定的索引号之间的字符。1234567891011stringObject.substring(start,stop)// start 必须 非负整 起始下标,num// stop 可选 非负整 比要提取位置+1 省略时,表示到最后// e.g.var str=\"Hello world!\"console.log(str.substring(3))console.log(str.substring(3,7))// lo world!// lo w 4、concat() 连接字符串。1234567stringObject.concat(stringX,stringX,...,stringX)// e.g.var str1=\"Hello \"var str2=\"world!\"console.log(str1.concat(str2))// Hello world! 5、split() 把字符串分割为字符串数组。123stringObject.split(separator,howmany)// separator 必需 字符串或正则 切割符号// howmany 可选 最大返回长度 省略忽视最大返回长度 注：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割注：String.split()与 Array.join 执行的操作是相反的 6、others1234567891011121314charAt() 返回在指定位置的字符。indexOf() 检索字符串。返回位置lastIndexOf() 从后向前搜索字符串。返回位置match() 找到一个或多个正则表达式的匹配。replace() 替换与正则表达式匹配的子串。search() 检索与正则表达式相匹配的值。sub() 把字符串显示为下标。sup() 把字符串显示为上标。toLocaleLowerCase() 把字符串转换为小写。toLocaleUpperCase() 把字符串转换为大写。toLowerCase() 把字符串转换为小写。toUpperCase() 把字符串转换为大写。toString() 返回字符串。valueOf() 返回某个字符串对象的原始值。 二、数组方法1、concat() 连接两个或更多的数组，并返回结果。1234567arrayObject.concat(arrayX,arrayX,......,arrayX)// e.g.var arr1=['hello'];var arr2=['world!'];console.log(arr1.concat(arr2))// ['Hello','world!'] 2、slice() 从某个已有的数组返回选定的元素(不修改原数组)1234567891011arrayObject.slice(start,end)// start 必需 起始下标 负数时,从尾部开始算起位置: -1 最后,-2 倒数二// end 可选 结束下标 省略时,表示到最后,负数时,同上// e.g.var arr=['thank','you','very','math'];console.log(arr.slice(2,3))console.log(arr)// ['very']// ['thank','you','very','math'] 3、splice() 删除元素，并向数组添加新元素(改变原数组)123456789101112arrayObject.splice(index,howmany,item1,.....,itemX)// index 必需 起始下标 负数时,从尾部开始算起位置: -1 最后,-2 倒数二// howmany 可选 删除数量 0:不删// item1,.....,itemX 可选 增加新项// e.g.var arr=['thank','you','very','math'];console.log(arr.splice(1,1,'xjw'))console.log(arr)// ['you']// ['thank','xjw','very','math'] 4、others123456789join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。pop() 删除并返回数组的最后一个元素push() 向数组的末尾添加一个或更多元素，并返回新的长度。shift() 删除并返回数组的第一个元素unshift() 向数组的开头添加一个或更多元素，并返回新的长度。reverse() 颠倒数组中元素的顺序。sort() 对数组的元素进行排序 注:a-b 正数换位置toString() 把数组转换为字符串，并返回结果。valueOf() 返回数组对象的原始值 三、字符串与数据都有的方法1.slice()2.concat()","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"phpMyAdmin无法登陆解决","slug":"phpMyAdmin无法登陆解决","date":"2018-08-31T03:53:39.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/08/31/phpMyAdmin无法登陆解决/","link":"","permalink":"https://xiaojw.xyz/2018/08/31/phpMyAdmin无法登陆解决/","excerpt":"","text":"问题ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: NO)ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES) 解析通常这种情况是没有设置密码或者密码错误导致的 解决首先确定 相关端口打开了 3306 888(默认) 1.关闭mysql 1/bin/systemctl stop mysql.service or1/etc/init.d/mysql stop 2.在mysql关闭的情况下： 1/bin/systemctl stop mysql.service --skip-grant-tables or1/etc/init.d/mysql start --skip-grant-tables 3.连接mysql,进入mysql命令行12345mysql -u root -p ## 出现password：的时候直接回车可以进入。mysql&gt; use mysql; Database changedmysql&gt; update user set password=password(\"123456\") where user=\"root\"; # 给root用户设置新密码mysql&gt; flush privileges; # 刷新数据库mysql&gt; quitBye # 退出mysql 改好之后,重启mysql服务就可以了。去掉这句 --skip-grant-tables","categories":[{"name":"后端","slug":"后端","permalink":"https://xiaojw.xyz/categories/后端/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://xiaojw.xyz/tags/后端/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://xiaojw.xyz/categories/后端/"}]},{"title":"使用canvas画环形进度条","slug":"使用canvas画环形进度条","date":"2018-08-30T11:07:06.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/08/30/使用canvas画环形进度条/","link":"","permalink":"https://xiaojw.xyz/2018/08/30/使用canvas画环形进度条/","excerpt":"","text":"效果展示 html1234&lt;canvas id=\"myCanvas\" width=\"300\" height=\"150\" style=\"border:1px solid #d3d3d3;\"&gt; Your browser does not support the HTML5 canvas tag.&lt;/canvas&gt; js1234567891011121314151617181920212223242526let canvas = document.getElementById('myCanvas')let ctx = canvas.getContext('2d')// 绘制 灰色层 底层ctx.beginPath()ctx.arc(100, 75, 50, 0, 2 * Math.PI)ctx.lineWidth = 10ctx.strokeStyle = \"#eee\";ctx.stroke()// 绘制 蓝色层 进度层ctx.beginPath()ctx.arc(100, 75, 50, -Math.PI / 2, 0)ctx.lineWidth = 10ctx.strokeStyle = \"#489cff\";ctx.stroke()// 绘制文字层ctx.font = \"20px Verdana\";/* 渐变let gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);gradient.addColorStop(0, \"magenta\");gradient.addColorStop(0.5, \"blue\");gradient.addColorStop(1, \"red\");ctx.fillStyle = gradient;*/ctx.fillStyle = \"#666\";ctx.fillText(\"25%\", 80, 84)","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"自定义百度云分享密码","slug":"自定义百度云分享密码","date":"2018-08-30T03:39:24.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/08/30/自定义百度云分享密码/","link":"","permalink":"https://xiaojw.xyz/2018/08/30/自定义百度云分享密码/","excerpt":"","text":"动态图片展示 1javascript:require([&quot;function-widget-1:share/util/service/createLinkShare.js&quot;]).prototype.makePrivatePassword=function()&#123;return prompt(&quot;请输入自定义的密码&quot;,&quot;1234&quot;)&#125; 使用方法：首先，选择要分享的文件，点击分享按钮。这时候，按F12打开控制台，切换至Console，输入代码按回车即可。 然后点击创建私密链接，会弹出输入框，输入密码即可！ 注意使用代码前要先点一下分享按钮，相关模块才会载入，这时候用代码才有效果。 转载自:流年似水博客转载自:西门吹雪","categories":[{"name":"其他","slug":"其他","permalink":"https://xiaojw.xyz/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://xiaojw.xyz/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://xiaojw.xyz/categories/其他/"}]},{"title":"动态路由-路由访问权限","slug":"动态路由-路由访问权限","date":"2018-08-30T02:42:53.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/08/30/动态路由-路由访问权限/","link":"","permalink":"https://xiaojw.xyz/2018/08/30/动态路由-路由访问权限/","excerpt":"","text":"动态路由控制权限 参考文章12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485login.vuelet dR = new Array();for (let i = 0; i &lt; dynamicRouter.length; i++) &#123; //第一层循环遍历动态路由表的每一个路由 let aside_list = this.aside_list for (let j = 0; j &lt; aside_list.length; j++) &#123; if (dynamicRouter[i].path === aside_list[j].path &amp;&amp; aside_list[j].isShow) &#123; // console.log(dynamicRouter[i]) dR.push(dynamicRouter[i]); // 符合条件的路由信息就放进数组里 if (!this.xjw) &#123; // this.firstShowPath = dynamicRouter[i] dR.push(dynamicRouter[2]); this.xjw = true &#125; &#125; else if (aside_list[j].path.indexOf('x') &amp;&amp; aside_list[j].isShow) &#123; if (!this.first) &#123; // 符合条件的路由的福袋必须访问的路由就放进数组里 dR.push(dynamicRouter[0]); dR.push(dynamicRouter[1]); this.first = true &#125; &#125; else if ( (aside_list[j].path.indexOf('xx') || aside_list[j].path.indexOf('xxx') || aside_list[j].path.indexOf('xxxx')) &amp;&amp; aside_list[j].isShow) &#123; if (!this.second) &#123; dR.push(dynamicRouter[1]); this.second = true &#125; &#125; &#125;&#125;this.xjw = nullthis.first = nullthis.second = null// console.log(dR)this.$router.addRoutes(dR.concat([&#123; //这里调用addRoutes方法，动态添加符合条件的路由 path: '*', redirect: '/404' //所有不匹配路径(*)都重定向到404，为什么写在这里而不放到静态路由表里可以查看“前端路上”的文章&#125;]));this.$router.push(this.firstShowPath); APP.vue// 获取登录状态if (!isLogin) &#123; return this.$router.push('/login');&#125; else &#123; let dR = new Array(); for (let i = 0; i &lt; dynamicRouter.length; i++) &#123; let aside_list = this.get_aside_list.aside_list // console.log(dynamicRouter[i]) for (let j = 0; j &lt; aside_list.length; j++) &#123; if (dynamicRouter[i].path === aside_list[j].path &amp;&amp; aside_list[j].isShow) &#123; // console.log(dynamicRouter[i]) dR.push(dynamicRouter[i]); //符合条件的路由信息就放进数组里 if (!this.xjw) &#123; dR.push(dynamicRouter[2]); this.xjw = true &#125; &#125; else if (aside_list[j].path.indexOf('x') &amp;&amp; aside_list[j].isShow) &#123; if (!this.first) &#123; dR.push(dynamicRouter[0]); dR.push(dynamicRouter[1]); this.first = true &#125; &#125; else if ( (aside_list[j].path.indexOf('xx') || aside_list[j].path.indexOf('xxx') || aside_list[j].path.indexOf('xxxx')) &amp;&amp; aside_list[j].isShow) &#123; if (!this.second) &#123; dR.push(dynamicRouter[1]); this.second = true &#125; &#125; &#125; &#125; this.xjw = null this.first = null this.second = null // console.log(dR) this.$router.addRoutes(dR);","categories":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xiaojw.xyz/categories/前端/"}]},{"title":"hexo 常用命令","slug":"hexo 常用命令","date":"2018-08-30T02:39:24.000Z","updated":"2020-07-08T02:45:38.089Z","comments":true,"path":"2018/08/30/hexo 常用命令/","link":"","permalink":"https://xiaojw.xyz/2018/08/30/hexo 常用命令/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 列出已安装依赖(局部/全局)12$ npm ls --depth 0 $ npm ls --depth 0 -g","categories":[{"name":"其他","slug":"其他","permalink":"https://xiaojw.xyz/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://xiaojw.xyz/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://xiaojw.xyz/categories/其他/"}]},{"title":"删除服务器乱码文件/目录","slug":"删除服务器乱码文件","date":"2018-08-30T02:20:58.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/08/30/删除服务器乱码文件/","link":"","permalink":"https://xiaojw.xyz/2018/08/30/删除服务器乱码文件/","excerpt":"","text":"方法一1.使用 ls -li 命令得到乱码文件的 inode 值1$ ls -li 2.使用 find . -inum 24609 -exec rm {} -rf \\; 命令删除乱码文件.其中24609替换为乱码文件的inode值. 注意空格 中英文符号\\;等1$ find . -inum 24609 -exec rm &#123;&#125; -rf \\; 方法二1.使用rm -rf 删除上一级目录，当然前提是需要备份你需要备份的数据.123456789101112131415一种思路：1. 比如/home下文件夹内含有乱码的文件2. mkdir tmp3. 将所有的文件首先移动到 mv * tmp/4.到tmp下 把所有有正常的显示字符的文件移动出来cd tmp ;mv [a-zA-Z0-9]* ..5.现在可以 rm -rf tmp 了","categories":[{"name":"服务器","slug":"服务器","permalink":"https://xiaojw.xyz/categories/服务器/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://xiaojw.xyz/tags/服务器/"}],"keywords":[{"name":"服务器","slug":"服务器","permalink":"https://xiaojw.xyz/categories/服务器/"}]},{"title":"文件管理php","slug":"文件管理php","date":"2018-08-30T01:27:59.000Z","updated":"2020-07-08T02:45:38.105Z","comments":true,"path":"2018/08/30/文件管理php/","link":"","permalink":"https://xiaojw.xyz/2018/08/30/文件管理php/","excerpt":"","text":"有些代码不是自己写的 所以格式不太同123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273&lt;?phpfunction fileAdir($dir) &#123; if (!is_dir($dir))&#123; mkdir($dir); chmod($dir,0777); $data = scandir(&quot;$dir&quot;); $allFile = array(); foreach ($data as $file) &#123; if($file != &apos;.&apos; &amp;&amp; $file != &apos;..&apos;) &#123; //判断是否是文件夹内的文件夹 $a = array( &apos;file&apos;=&gt;$file, &apos;isDir&apos;=&gt;is_dir($dir. &apos;/&apos; .$file), &apos;name&apos;=&gt;$dir . &apos;/&apos; .$file ); array_push($allFile, $a); &#125; &#125; return $allFile; &#125; else&#123; $data = scandir(&quot;$dir&quot;); $allFile = array(); foreach ($data as $file) &#123; if($file != &apos;.&apos; &amp;&amp; $file != &apos;..&apos;) &#123; //判断是否是文件夹内的文件夹 $a = array( &apos;file&apos;=&gt;$file, &apos;isDir&apos;=&gt;is_dir($dir. &apos;/&apos; .$file), &apos;name&apos;=&gt;$dir . &apos;/&apos; .$file ); array_push($allFile, $a); &#125; &#125; return $allFile; &#125;&#125;/** 读取文件类 **/class file &#123; public $file; public $filename; //文件名字 public $filetype; //文件类型 public $filesize; //文件大小 public $fileopen; //打开文件 public $fileread; //读取文件 //写入变量 public $filepath; public $filecontent; //保存文件用到的文件内容 public $fileput; //文件写入 public function edits($files)&#123; $this-&gt;file = $files; if(!file_exists($this-&gt;file))&#123; die(&quot;文件不存在！&quot;); &#125; $this-&gt;fileopen = fopen($this-&gt;file, &apos;r&apos;); if(!$this-&gt;fileopen)&#123; die(&quot;文件读取失败&quot;); &#125; //$this-&gt;fileread = htmlspecialchars($this-&gt;fileread); //开始获取文件的后缀名 $filestr = strlen($this-&gt;file); $filepoint = strrpos($this-&gt;file, &apos;.&apos;); $filesub = substr($this-&gt;file, $filepoint+1); $this-&gt;filetype = $filesub; $this-&gt;filename = basename($this-&gt;file); $this-&gt;filesize = filesize($this-&gt;file); if($this-&gt;filesize===0)&#123; return array( &apos;filetype&apos;=&gt;$this-&gt;filetype, &apos;filename&apos;=&gt;$this-&gt;filename, &apos;filecontent&apos;=&gt;&apos;&apos;, &apos;filepath&apos;=&gt;$this-&gt;file ); exit; &#125; $this-&gt;fileread = fread($this-&gt;fileopen,$this-&gt;filesize); // 读取中文 //$this-&gt;fileread =iconv(&apos;gb2312&apos;, &apos;utf-8&apos;, $this-&gt;fileread); //以数组形式返回：文件类型 文件名称 文件内容 文件路径 return array( &apos;filetype&apos;=&gt;$this-&gt;filetype, &apos;filename&apos;=&gt;$this-&gt;filename, &apos;filecontent&apos;=&gt;$this-&gt;fileread, &apos;filepath&apos;=&gt;$this-&gt;file ); //关闭文件 fclose($this-&gt;file); &#125; /* 修改文件函数 */ public function bc($filepath,$filecontent)&#123; $this-&gt;filepath = $filepath; //访问文件 $this-&gt;fileopen = file_get_contents($this-&gt;filepath); if(!$this-&gt;fileopen)&#123; //die(&apos;文件打开失败&apos;); &#125; //获取传进来的文件内容 $this-&gt;filecontent = $filecontent; //反转义html //$this-&gt;filecontent = htmlspecialchars_decode($this-&gt;filecontent); //写入文件 $this-&gt;fileput = file_put_contents($this-&gt;filepath, $this-&gt;filecontent); if($this-&gt;fileput)&#123; return &apos;修改文件成功&apos;; &#125;else &#123; return &apos;修改文件失败&apos;; &#125; &#125; // 创建文件夹 public function create_folder($dir) &#123; if (!file_exists($dir))&#123; //mkdir($dir,0777,true); mkdir($dir); chmod($dir,0777); return &apos;创建文件夹成功&apos;; &#125; else &#123; return &apos;创建文件夹已存在&apos;; &#125; &#125; // 创建文件 public function create_file($dir) &#123; if (!file_exists($dir))&#123; $handle = fopen($dir, &apos;w&apos;); chmod($dir,0777); if($handle)&#123; return &apos;创建文件成功&apos;; &#125; else&#123; return &apos;创建文件失败&apos;; &#125; &#125; else &#123; return &apos;需创建的文件已经存在&apos;; &#125; &#125; // 重命名文件/文件夹 public function fileRename($old_name,$new_name) &#123; if(!file_exists($new_name)||file_exists($old_name))&#123; $result = rename($old_name,$new_name); if($result)&#123; return &apos;重命名成功&apos;; &#125; else&#123; return &apos;重命名失败&apos;; &#125; &#125; else &#123; return &apos;目标文件已存在或原文件不存在&apos;; &#125; &#125; // 复制文件夹及文件夹下文件 public function copyDirAndFile($src,$dst) &#123; // 原目录，复制到的目录 if(file_exists($src))&#123; $dir = opendir($src); @mkdir($dst); chmod($dst,0777); while(false !== ($file = readdir($dir))) &#123; if (( $file != &apos;.&apos; ) &amp;&amp; ( $file != &apos;..&apos; )) &#123; if (is_dir($src . &apos;/&apos; . $file)) &#123; $this-&gt;copyDirAndFile($src . &apos;/&apos; . $file,$dst . &apos;/&apos; . $file); chmod($dst . &apos;/&apos; . $file,0777); &#125; else &#123; copy($src . &apos;/&apos; . $file,$dst . &apos;/&apos; . $file); chmod($dst . &apos;/&apos; . $file,0777); &#125; &#125; &#125; closedir($dir); return true; &#125; else &#123; return false; &#125; &#125; // 删除文件夹及文件夹下文件 public function delDirAndFile($dirName)&#123; if(file_exists($dirName))&#123; if ($handle = opendir(&quot;$dirName&quot; )) &#123; while (false !== ($item=readdir($handle))) &#123; if ($item != &quot;.&quot; &amp;&amp; $item != &quot;..&quot;) &#123; if (is_dir( &quot;$dirName/$item&quot;)) &#123; $this-&gt;delDirAndFile( &quot;$dirName/$item&quot; ); &#125; else &#123; if(unlink( &quot;$dirName/$item&quot; ))&#123; // echo &quot;成功删除文件： $dirName/$item\\n&quot;; &#125; &#125; &#125; &#125; closedir( $handle ); if(rmdir( $dirName )) &#123; // echo &quot;成功删除目录： $dirName\\n&quot;; &#125; &#125; return true; &#125; else&#123; return false; &#125; &#125; // 剪切文件夹及文件夹下文件 public function cutDirAndFile($src,$dst) &#123; // 原目录，复制到的目录 if(file_exists($src))&#123; $dir = opendir($src); @mkdir($dst); chmod($dst,0777); while(false !== ($file = readdir($dir))) &#123; if (( $file != &apos;.&apos; ) &amp;&amp; ( $file != &apos;..&apos; )) &#123; if (is_dir($src . &apos;/&apos; . $file)) &#123; $this-&gt;copyDirAndFile($src . &apos;/&apos; . $file,$dst . &apos;/&apos; . $file); chmod($dst . &apos;/&apos; . $file,0777); &#125; else &#123; copy($src . &apos;/&apos; . $file,$dst . &apos;/&apos; . $file); chmod($dst . &apos;/&apos; . $file,0777); //unlink($src . &apos;/&apos; . $file); &#125; &#125; &#125; $file = new file(); $delete = $file-&gt;delDirAndFile($src); if(!$delete)&#123; return &apos;文件夹删除失败&apos;; &#125; $file = null; closedir($dir); return true; &#125; else &#123; return false; &#125; &#125; // 复制单个文件 public function fileCopy($source_name,$target_name) &#123; if(!file_exists($target_name)||file_exists($source_name))&#123; //return copy($source_name,$target_name)?true:false; $result = copy($source_name,$target_name); chmod($target_name,0777); return $result; if($result)&#123; return &apos;复制文件成功&apos;; &#125; else &#123; return &apos;复制文件失败&apos;; &#125; &#125; else &#123; return &apos;目标文件已经存在或者原始文件不存在&apos;; &#125; &#125; // 删除单个文件 public function fileDelete($del_name) &#123; if(file_exists($del_name))&#123; $result = unlink($del_name); if($result)&#123; return &apos;删除文件成功&apos;; &#125; else &#123; return &apos;删除文件失败&apos;; &#125; &#125; else &#123; return &apos;要删除的文件不存在&apos;; &#125; &#125; // 剪切单个文件 public function fileCut($source_name,$target_name) &#123; if(!file_exists($target_name)||file_exists($source_name))&#123; //return copy($source_name,$target_name)?true:false; $result = copy($source_name,$target_name); chmod($target_name,0777); unlink($source_name); if($result)&#123; return &apos;剪切文件成功&apos;; &#125; else &#123; return &apos;剪切文件失败&apos;; &#125; &#125; else &#123; return &apos;目标文件已经存在或者原始文件不存在&apos;; &#125; &#125;&#125;?&gt;","categories":[{"name":"后端","slug":"后端","permalink":"https://xiaojw.xyz/categories/后端/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://xiaojw.xyz/tags/后端/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://xiaojw.xyz/categories/后端/"}]}]}